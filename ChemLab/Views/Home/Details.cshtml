@model ChemLab.Data.Entity.LabPractice

@{
    ViewData["Title"] = "Details";
}

<h1 class="display-4">@ViewData["Title"]</h1>
<hr />

<link rel="stylesheet" type="text/css" href="~/lib/libs/dist/themes/default/kekule.css" />


<style>

    /* Общие стили */
    #composer {
        height: 450px;
        width: 600px;
        float: left;
    }

    .FloatClearer {
        clear: both;
    }

    .table-container {
        display: flex;
        flex-direction: row;
        overflow-x: auto;
    }

    #reactantTable,
    #productTable {
        margin-right: 20px;
        width: auto;
    }

    /* Стили для таблиц */
    table {
        width: 100%;
        border-collapse: collapse;
        border-spacing: 0;
    }

    th, td {
        padding: 12px 15px;
        text-align: left;
        border-bottom: 1px solid #ddd;
    }

    th {
        background-color: #f8f9fa;
        color: #333;
        font-weight: bold;
        text-transform: uppercase;
    }

    tr:last-child {
        display: none;
    }

    tr:nth-child(even) {
        background-color: #f2f2f2;
    }

    td:not(:first-child):hover {
        background-color: #ddd;
    }

        td:not(:first-child):hover ~ td {
            background-color: transparent;
        }

    /* Стили для модального окна */
    .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
    }

    .modal-content {
        background-color: #fefefe;
        margin: 15% auto;
        padding: 20px;
        border: 1px solid #888;
        width: 80%;
        max-width: 600px;
        text-align: center;
    }

        .modal-content button {
            margin-top: 10px;
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

    /* Стили для текстовых полей и кнопок */
    input[type="text"],
    textarea,
    button {
        margin: 0.3em 0.5em;
        padding: 0.5em;
        box-sizing: border-box;
        width: auto;
    }


    .hidden {
        display: none;
    }


    .delete-button {
        background-color: transparent;
        border: none;
        cursor: pointer;
        font-size: 1.2rem;
        margin-left: 10px;
    }

    .delete-button:hover {
        color: red;
    }

    .error-message {
        display: none;
        position: absolute;
        background-color: #f44336;
        color: white;
        padding: 5px;
        border-radius: 3px;
        z-index: 2;
        font-size: 0.8em;
    }

    label {
        position: relative;
        display: inline-block;
    }



</style>
<button id="toggleButtonSave">Сохранить молекулу</button>
<button id="toggleRowsButton" class="hidden">Скрыть/показать молекулы</button>

<div id="contentToToggle" class="hidden">
    <div>
        <button id="btnSetAnchor" data-widget="Kekule.Widget.Button" data-text="Set Anchor(s)">Set Anchor(s)</button>
        <p id="setAnchorError" class="error-message">Произошла ошибка при установке якоря</p>
        <select id="selStructType" data-widget="Kekule.Widget.SelectBox"></select>
        <label>
            Name:
            <input id="editName" type="text" data-widget="Kekule.Widget.TextBox" placeholder="Имя">
            <p id="nameError" class="error-message">Пожалуйста, заполните это поле</p>
        </label>
        <label>
            Abbr:
            <input id="editAbbr" type="text" data-widget="Kekule.Widget.TextBox" placeholder="Аббревиатура">
            <p id="abbrError" class="error-message">Пожалуйста, заполните это поле</p>
        </label>
        <label>
            Formula Text:
            <input id="editFormulaText" type="text" data-widget="Kekule.Widget.TextBox" />
        </label>
        <label>
            Input Texts:
            <textarea id="editInputTexts" type="text" data-widget="Kekule.Widget.TextArea"></textarea>
        </label>
    </div>

    <div>
        <button id="btnAddRepoItem" data-widget="Kekule.Widget.Button" data-text="Add item and update">Add item and update</button>
    </div>

</div>


<div id="stage">
    <div id="composer"></div>
    <div class="FloatClearer"></div>
</div>


<div class="table-container">
    <table id="reactantTable">
        <tr>
            <td>Формула</td>
        </tr>
        <tr>
            <td>MW</td>
        </tr>
        <tr>
            <td>m</td>
        </tr>
        <tr>
            <td>n</td>
        </tr>
        <tr>
            <td>Экв.</td>
        </tr>
        <tr>
            <td>Основной</td>
        </tr>
        <tr>
            <td><input type="hidden" name="unique" value="">
        </tr>
    </table>

    <table id="productTable">
        <tr>
            <td>Формула</td>
        </tr>
        <tr>
            <td>MW</td>
        </tr>
        <tr>
            <td>m</td>
        </tr>
        <tr>
            <td>n</td>
        </tr>
        <tr>
            <td>Выход.</td>
        </tr>
        <tr>
            <td>Основной</td>
        </tr>
        <tr>
            <td><input type="hidden" name="unique" value="">
        </tr>
    </table>
</div>

<div id="editor-container"></div>

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CAS Number Lookup</title>
<script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>

<script src="~/lib/libs/raphael-min.2.0.1.js"></script>
<script src="~/lib/libs/dist/kekule.js?"></script>

<script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
<link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">

<img id="infoImage" src="~/info.png" alt="Информация" style="width: 20px; height: 20px;">

<script>

    function showErrorUnderButton() {
        var setAnchorError = document.getElementById('setAnchorError');
        setAnchorError.style.display = 'block';

        setTimeout(function () {
            setAnchorError.style.display = 'none';
        }, 5000);
    }


    document.getElementById('editName').addEventListener('input', validateName);
    document.getElementById('editAbbr').addEventListener('input', validateAbbr);

    function validateName() {
        var nameValue = this.value.trim();
        var nameError = document.getElementById('nameError');

        if (nameValue === '') {
            nameError.style.display = 'block';
        } else {
            nameError.style.display = 'none';
        }
    }

    function validateAbbr() {
        var abbrValue = this.value.trim();
        var abbrError = document.getElementById('abbrError');

        if (abbrValue === '') {
            abbrError.style.display = 'block';
        } else {
            abbrError.style.display = 'none';
        }
    }

    document.getElementById('btnAddRepoItem').addEventListener('click', function () {
        validateName.call(document.getElementById('editName'));
        validateAbbr.call(document.getElementById('editAbbr'));

        var nameValue = document.getElementById('editName').value.trim();
        var abbrValue = document.getElementById('editAbbr').value.trim();

        if (nameValue === '' || abbrValue === '') {
            return false;
        }
    });

    document.getElementById('editName').addEventListener('click', function () {
        document.getElementById('nameError').style.display = 'none';
    });

    document.getElementById('editAbbr').addEventListener('click', function () {
        document.getElementById('abbrError').style.display = 'none';
    });

    var ctrlPressed = false;

    document.addEventListener('keydown', function (event) {
        // console.log("listen", event);
        if (event.key === 'Control') {
            ctrlPressed = true;
        } else if (ctrlPressed && event.key === '1') {
            event.preventDefault();
            handleBondType('Single');
        } else if (ctrlPressed && event.key === '2') {
            event.preventDefault();
            handleBondType('Double');
        } else if (ctrlPressed && event.key === '3') {
            event.preventDefault();
            handleBondType('Triple');
        }
    });

    document.addEventListener('keyup', function (event) {
        if (event.key === 'Control') {
            ctrlPressed = false;
        } 
    });

    function handleBondType(bondType) {
        var bondToolButton = document.querySelector('.K-Chem-MolBondIaController');

        if (bondToolButton) {
            bondToolButton.focus();
            bondToolButton.dispatchEvent(new PointerEvent('pointerdown', { bubbles: true }));
            bondToolButton.dispatchEvent(new PointerEvent('pointerup', { bubbles: true }));

            setTimeout(function () {
                var bondButton = document.querySelector('.K-Chem-MolBondIaController-' + bondType);

                if (bondButton) {
                    bondButton.focus();
                    bondButton.dispatchEvent(new PointerEvent('pointerdown', { bubbles: true }));
                    bondButton.dispatchEvent(new PointerEvent('pointerup', { bubbles: true }));

                    bondButton.click();
                } else {
                    console.error('Кнопка bondButton не найдена');
                }
            }, 50);
        } else {
            console.error('Кнопка bondToolButton не найдена');
        }
    }

    window.addEventListener('DOMContentLoaded', insertEditorContent);

    async function loadEditorContent() {
        let id = @ViewBag.Id;
        try {
            let data = await $.ajax({
                type: 'GET',
                url: '/chemeditor/get_text/' + id,
                contentType: 'application/json; charset=utf-8'
            });
            return data;
        } catch (error) {
            console.error('Произошла ошибка в loadEditorContent:', error);
        }
    }

    async function insertEditorContent() {
        try {
            let editorContent = await loadEditorContent();
            if (editorContent) {
                let quill = document.querySelector('.ql-editor');
                quill.innerHTML = editorContent;
            }
        } catch (err) {
            console.error('Произошла ошибка при вставке текста в редактор:', err);
        }
    }

    const calendarIcon = `
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="14" height="14">
      <path d="M21 2H18V0H16V2H8V0H6V2H3A3 3 0 0 0 0 5V24H24V5A3 3 0 0 0 21 2ZM2 5A1 1 0 0 1 3 4H21A1 1 0 0 1 22 5V8H2ZM2 22V10H22V22Z"/>
      <rect x="15" y="13" width="2" height="2"/>
      <rect x="11" y="13" width="2" height="2"/>
      <rect x="7" y="13" width="2" height="2"/>
      <rect x="15" y="17" width="2" height="2"/>
      <rect x="11" y="17" width="2" height="2"/>
      <rect x="7" y="17" width="2" height="2"/>
    </svg>`;

    const icons = Quill.import('ui/icons');
    icons['customCurrentDate'] = calendarIcon;

    function insertCurrentDate() {
        var currentDate = new Date();
        var dateString = currentDate.toLocaleDateString();
        var timeString = currentDate.toLocaleTimeString();
        var quill = this.quill;
        quill.focus();
        quill.insertText(quill.getSelection().index, '\n' + dateString + ' ' + timeString + '\n', { color: 'blue' });
    }

    const toolbarOptions = [
        [{ 'header': [1, 2, 3, false] }],
        ['bold', 'italic', 'underline', 'code-block'],
        ['link', 'image', 'video', 'formula', { 'customCurrentDate': 'Insert current date' }],
        [{ 'list': 'ordered' }, { 'list': 'bullet' }, { 'list': 'check' }, { 'indent': '-1' }, { 'indent': '+1' }, { 'direction': 'rtl' }],
        [{ 'script': 'sub' }, { 'script': 'super' }],
        [{ 'color': [] }, { 'background': [] }]
    ];

    const quill = new Quill('#editor-container', {
        modules: {
            toolbar: {
                container: toolbarOptions,
                handlers: {
                    'customCurrentDate': insertCurrentDate
                }
            }
        },
        theme: 'snow'
    });

    document.getElementById('editor-container').addEventListener('focusout', async function () {
        await saveEditorContent();
    });

    async function saveEditorContent() {
        try {
            let editorHtml = document.querySelector('.ql-editor').innerHTML; 
            let data = {
                Content: editorHtml
            };

            let id = @ViewBag.Id;

            let response = await fetch('/chemeditor/save_text/' + id, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });

            if (response.ok) {
                console.log('Текст успешно загружен.');
            } else {
                console.error('Произошла ошибка при отправке текста:', response.statusText);
            }
        } catch (err) {
            console.error('Произошла ошибка в saveEditorContent:', err);
            throw err;
        }
    }

    const toggleButtonSave = document.getElementById('toggleButtonSave');
    const contentToToggle = document.getElementById('contentToToggle');
    const toggleRowsButton = document.getElementById('toggleRowsButton');

    toggleButtonSave.addEventListener('click', () => {
        contentToToggle.classList.toggle('hidden');
        toggleRowsButton.classList.toggle('hidden'); // Переключаем видимость кнопки
    });

    toggleRowsButton.addEventListener('click', () => {
        const rows = contentToToggle.querySelectorAll('.molecule-row');
        rows.forEach(row => {
            row.classList.toggle('hidden');
        });
    });


    const TABLE_ROWS = {
        FORMULA: 0,
        MW: 1,
        M: 2,
        N: 3,
        EQV: 4,
        ACTION: 5,
        UNIQUE: 6,
    };

    class Table {
        constructor(composer) {
            this.reactantFragments = new Map();
            this.productFragments = new Map();
            this.activeFragment = null;
            this.composer = composer;''
        }
        tableReactant = document.getElementById("reactantTable");
        tableProduct = document.getElementById("productTable");

        printFragmentIds() {
            console.log("Reactant Fragment IDs:");
            for (let fragmentId of this.reactantFragments.keys()) {
                console.log(fragmentId);
            }

            console.log("Product Fragment IDs:");
            for (let fragmentId of this.productFragments.keys()) {
                console.log(fragmentId);
            }
        }


        formulaCell(fragment, table, content, flagNew, index) {
            const formulaRow = table.rows[TABLE_ROWS.FORMULA];
            let formulaCell;
            if (flagNew) {
                formulaCell = formulaRow.insertCell(formulaRow.cells.length);
            } else {
                formulaCell = formulaRow.cells[index];

            }
            formulaCell.innerHTML = content;

            const infoButton = this.createInfoButton(fragment);
            formulaCell.appendChild(infoButton);
        }

        createInfoButton(data) {
            const infoButton = document.createElement("button");
            infoButton.type = "button";
            infoButton.style.border = "none";
            infoButton.style.padding = "0";
            infoButton.style.backgroundColor = "transparent";
            infoButton.style.marginLeft = "5px";

            const clonedImage = document.getElementById("infoImage").cloneNode(true);
            infoButton.appendChild(clonedImage);

            infoButton.addEventListener("click", () => {
                const smiles = Kekule.IO.saveFormatData(data.fragment, 'smi');
                this.openInfoWindowWithChemInfo(smiles, data.formula);
            });

            return infoButton;
        }

        openInfoWindowWithChemInfo(smiles, formula) {
            try {
                var modal = document.createElement("div");
                modal.className = "modal";
                var modalContent = document.createElement("div");
                modalContent.className = "modal-content";

                var formulaText = document.createElement("p");
                formulaText.innerText = "Дополнительная информация о " + formula;
                modalContent.appendChild(formulaText);

                var loadingText = document.createElement("p");
                loadingText.innerText = "Идет загрузка данных...";
                modalContent.appendChild(loadingText);

                modal.appendChild(modalContent);
                document.body.appendChild(modal);
                modal.style.display = "block";

                this.getChemInfoFromServer(smiles)
                    .then((chemInfo) => {
                        loadingText.style.display = "none";          

                        if (chemInfo) {
                            var casNumberText = document.createElement("p");
                            casNumberText.innerText = "CAS Number: " + chemInfo.casNumber;
                            modalContent.appendChild(casNumberText);

                            var firstSynonymText = document.createElement("p");
                            firstSynonymText.innerText = "Имя: " + chemInfo.firstSynonym;
                            modalContent.appendChild(firstSynonymText);

                            var molecularWeightText = document.createElement("p");
                            molecularWeightText.innerText = "Молекулярная масса: " + chemInfo.molecularWeight;
                            modalContent.appendChild(molecularWeightText);

                            var exactMassText = document.createElement("p");
                            exactMassText.innerText = "Точная масса: " + chemInfo.exactMass;
                            modalContent.appendChild(exactMassText);

                            var image = document.createElement("img");
                            image.src = "data:image/png;base64," + chemInfo.imageDataUrl;
                            modalContent.appendChild(image);
                        } else {
                            var errorText = document.createElement("p");
                            errorText.innerText = "Не удалось найти информацию";
                            modalContent.appendChild(errorText);
                        }

                        var closeButton = document.createElement("button");
                        closeButton.innerText = "Закрыть";
                        closeButton.addEventListener("click", function () {
                            modal.style.display = "none";
                        });
                        modalContent.appendChild(closeButton);
                    })
                    .catch((error) => {
                        console.error('Ошибка:', error.message);
                    });
            } catch (error) {
                console.error('Ошибка:', error.message);
            }
        }

        async getChemInfoFromServer(smiles) {
            try {
                const response = await fetch(`/api/pubchem/get_cas/${encodeURIComponent(smiles)}`);
                if (!response.ok) {
                }
                const data = await response.json();
                if (data.success) {
                    const casNumber = data.casNumber;
                    const firstSynonym = data.firstSynonym;
                    const exactMass = data.exactMass;
                    const molecularWeight = data.molecularWeight;
                    const imageDataUrl = data.image;

                    return { casNumber, firstSynonym, exactMass, molecularWeight, imageDataUrl };
                } else {
                    return null;
                }
            } catch (error) {
                return null;
            }
        }

        mwCell(table, content, flagNew, index) {
            const mwRow = table.rows[TABLE_ROWS.MW];
            let mwCell;
            if (flagNew) {
                mwCell = mwRow.insertCell(mwRow.cells.length);
            } else {
                mwCell = mwRow.cells[index];
            }
            mwCell.innerHTML = content.toFixed(4);
        }

        nCell(table, fragment, flagNew, index) {

            const nRow = table.rows[TABLE_ROWS.N];
            let nCell;
            if (flagNew) {
                nCell = nRow.insertCell(nRow.cells.length);
                if (this.activeFragment) {  //  проверить как будет работать с переносимыми столбцами TO DO
                    var nValueBase = this.activeFragment.n;
                    var eqvValueBase = this.activeFragment.equivalent;
                    fragment.n = (nValueBase / eqvValueBase);
                }
            } else {
                nCell = nRow.cells[index];
            }

            //
            const nInput = document.createElement("input");
            nInput.type = "text";
            nInput.className = "n-input";
            nInput.value = this.formatNumber(fragment.n * this.multiplierUnit(fragment, false));

            nCell.innerHTML = '';
            nCell.appendChild(nInput);

            nInput.addEventListener('blur', (e) => {
                if (this.validateProperty(e.target)) {
                    if (this.checkSimilar(nInput.value, fragment.n * this.multiplierUnit(fragment, false))) {
                        nInput.value = this.formatNumber(fragment.n * this.multiplierUnit(fragment, false));
                    } else {
                        fragment.n = nInput.value / this.multiplierUnit(fragment, false);
                        nInput.value = this.formatNumber(nInput.value);
                        // console.log("ProcessingOtherFieldsForN");
                        this.ProcessingOtherFieldsForN(e.target.value, fragment);
                    }
                } else {
                    fragment.n = "";
                }
            });

            const nUnitSelect = this.createNUnitSelect(fragment, nInput);
            nCell.appendChild(nUnitSelect);
        }

        createNUnitSelect(data, nInput) {
            const nUnitSelect = document.createElement("select");
            nUnitSelect.className = "n-unit-select";
            const options = ["моль", "ммоль"];
            for (let i = 0; i < options.length; i++) {
                const option = document.createElement("option");
                option.value = options[i];
                option.text = options[i];
                if (data.nUnit === "моль" && options[i] === "моль") {
                    option.selected = true;
                } else if (data.nUnit === "ммоль" && options[i] === "ммоль") {
                    option.selected = true;
                }
                nUnitSelect.appendChild(option);
            }

            nUnitSelect.addEventListener('change', (e) => {
                if (this.handleMUnitChange(e, nInput, data, false)) {
                    nInput.value = this.formatNumber(data.n / 1000);
                } else {
                    nInput.value = this.formatNumber(data.n);
                }
                this.createOrUpdateColumn(data, false);
                this.composer.sendDataToServerAsync();
            });
            return nUnitSelect;
        }

        mCell(table, fragment, flagNew, index) {
            const mInput = document.createElement("input");
            mInput.type = "text";
            mInput.className = "m-input";

            const mRow = table.rows[TABLE_ROWS.M];
            let mCell;
            if (flagNew) {
                mCell = mRow.insertCell(mRow.cells.length);
                if (this.activeFragment) {  //  проверить как будет работать с переносимыми столбцами TO DO
                    fragment.m = (fragment.n * fragment.molarMass / 1000);
                    mInput.value = this.formatNumber(fragment.m * this.multiplierUnit(fragment, true));
                } else if (fragment.m !== "" || fragment.m !== 0.00) {
                    mInput.value = this.formatNumber(fragment.m * this.multiplierUnit(fragment, true));
                }
            } else {
                mCell = mRow.cells[index];
                mInput.value = this.formatNumber(fragment.n * fragment.molarMass / 1000 * this.multiplierUnit(fragment, true));
            }

            mCell.innerHTML = '';
            mCell.appendChild(mInput);

            mInput.addEventListener('blur', (e) => {
                if (this.validateProperty(e.target)) {
                    if (this.checkSimilar(mInput.value, fragment.m * this.multiplierUnit(fragment, true))) {
                        mInput.value = this.formatNumber(fragment.m * this.multiplierUnit(fragment, true));
                    } else {
                        fragment.m = mInput.value / this.multiplierUnit(fragment, true);
                        mInput.value = this.formatNumber(mInput.value);
                        // console.log("ProcessingOtherFieldsForM");
                        this.ProcessingOtherFieldsForM(e.target.value, fragment);
                    }
                } else {
                    fragment.m = "";
                }
            });

            const mUnitSelect = this.createMUnitSelect(fragment, mInput);
            mCell.appendChild(mUnitSelect);
        }

        createMUnitSelect(data, mInput) {
            const mUnitSelect = document.createElement("select");
            mUnitSelect.className = "m-unit-select";
            const options = ["г", "мг"];
            for (let i = 0; i < options.length; i++) {
                const option = document.createElement("option");
                option.value = options[i];
                option.text = options[i];
                if (data.mUnit === "мг" && options[i] === "мг") {
                    option.selected = true;
                } else if (data.mUnit === "г" && options[i] === "г") {
                    option.selected = true;
                }
                mUnitSelect.appendChild(option);
            }

            mUnitSelect.addEventListener('change', (e) => {
                if (this.handleMUnitChange(e, mInput, data, true)) {
                    mInput.value = this.formatNumber(data.m * 1000);
                    // console.log("m = ", data.m);
                    // console.log("mInput.value = ", this.formatNumber(data.m * 1000));
                    // console.log("mInput.value = ", mInput.value);
                } else {
                    mInput.value = this.formatNumber(data.m);
                    // console.log("m = ", data.m);
                    // console.log("mInput.value = ", this.formatNumber(data.m));
                    // console.log("mInput.value = ", mInput.value);
                }
                this.createOrUpdateColumn(data, false);
                this.composer.sendDataToServerAsync();
            });
            return mUnitSelect;
        }


        handleMUnitChange(e, mInput, fragment, flagM) {
            var selectedUnit = e.target.value;
            if (flagM) {
                if (selectedUnit === "мг") {
                    fragment.mUnit = "мг";
                    return true;
                } else if (selectedUnit === "г") {
                    fragment.mUnit = "г";
                    return false;
                }
            } else {
                if (selectedUnit === "моль") {
                    fragment.nUnit = "моль";
                    return true;
                } else if (selectedUnit === "ммоль") {
                    fragment.nUnit = "ммоль";
                    return false;
                }
            }

        }

        ProcessingOtherFieldsForM(value, fragmentInfo) {
            var mValue = value / this.multiplierUnit(fragmentInfo, true);
            var newNvalue = (mValue / fragmentInfo.molarMass * 1000);
            fragmentInfo.n = newNvalue;
            fragmentInfo.m = mValue;
            this.createOrUpdateColumn(fragmentInfo, false);

            if (fragmentInfo.action === true) {
                this.reactantFragments.forEach((value, key) => {
                    if (key !== fragmentInfo.fragmentId) {
                        value.m = (value.molarMass / fragmentInfo.molarMass * fragmentInfo.m * value.equivalent / fragmentInfo.equivalent);
                        value.n = (value.m / value.molarMass * 1000);
                        this.createOrUpdateColumn(value, false);
                    }
                });

                this.productFragments.forEach((value, key) => {
                    if (key !== fragmentInfo.fragmentId) {
                        value.m = (value.molarMass / fragmentInfo.molarMass * fragmentInfo.m * value.equivalent / fragmentInfo.equivalent);
                        value.n = (value.m / value.molarMass * 1000);
                        this.createOrUpdateColumn(value, false);
                    }
                });
            }
            console.log("sendDataToServerAsync in ProcessingOtherFieldsForM");
            this.composer.sendDataToServerAsync();
        }

        ProcessingOtherFieldsForN(value, fragmentInfo) {
            var nValue = value / this.multiplierUnit(fragmentInfo, false);
            var newMvalue = (nValue * fragmentInfo.molarMass / 1000);
            fragmentInfo.n = nValue;
            fragmentInfo.m = newMvalue;
            this.createOrUpdateColumn(fragmentInfo, false);

            if (fragmentInfo.action === true) {
                this.reactantFragments.forEach((value, key) => {
                    if (key !== fragmentInfo.fragmentId) {
                        value.n = (value.equivalent / fragmentInfo.equivalent * fragmentInfo.n);
                        value.m = (value.n * value.molarMass / 1000);
                        this.createOrUpdateColumn(value, false);
                    }
                });

                this.productFragments.forEach((value, key) => {
                    if (key !== fragmentInfo.fragmentId) {
                        value.n = (value.equivalent / fragmentInfo.equivalent * fragmentInfo.n);
                        value.m = (value.n * value.molarMass / 1000);
                        this.createOrUpdateColumn(value, false);
                    }
                });
            }
            console.log("sendDataToServerAsync in ProcessingOtherFieldsForN");
            this.composer.sendDataToServerAsync();
        }

        actionCell(table, fragment, flagNew) {
            if (!flagNew) {
                return;
            }
            const actionRow = table.rows[TABLE_ROWS.ACTION];
            const actionCell = actionRow.insertCell(actionRow.cells.length);


            const radioInput = document.createElement("input");
            radioInput.type = 'radio';
            radioInput.name = 'action';
            radioInput.className = 'action';

            if (fragment.action == true) {
                radioInput.checked = true;
            }

            radioInput.addEventListener('change', () => {
                // console.log("action change:", fragment.fragmentId);
                this.activeFragment.action = false;
                fragment.action = true;
                this.activeFragment = fragment;
                this.createOrUpdateColumn(fragment, false);
                // resetAllActionsExcept(fragment.fragmentId);
                if (fragment.n !== "" && fragment.m !== "") {
                    this.updateEmptyFields(fragment, true);
                    this.updateEmptyFields(fragment, false);
                }

                // this.reactantFragments.forEach((value, key) => {
                    // this.createOrUpdateColumn(value, false);
                // });

                this.productFragments.forEach((value, key) => {
                    this.createOrUpdateColumn(value, false);
                });
                console.log("sendDataToServerAsync in radioInput on change");
                this.composer.sendDataToServerAsync();

            });

            actionCell.appendChild(radioInput);
        }

        updateEmptyFields(activeFragment, flagReactant) {
            const data = flagReactant ? this.reactantFragments : this.productFragments;
            for (var [key, element] of data.entries()) {
                if (element.action === false) {
                    // console.log("in upempty, element.n=", element.n, "element.m=", element.m);
                    // if (element.n === "" && element.m === "") {
                    if (this.checkEmpty(element.n) && this.checkEmpty(element.m)) {
                        element.n = activeFragment.n * element.equivalent / activeFragment.equivalent;
                        element.m = (element.n * element.molarMass / 1000);
                        this.createOrUpdateColumn(element, false);
                    // } else if (element.n === "") {
                    } else if (this.checkEmpty(element.n)) {
                        element.n = (element.m / element.molarMass * 1000);
                        this.createOrUpdateColumn(element, false);
                    // } else if (element.m === "") {
                    } else if (this.checkEmpty(element.m)) {
                        element.m = (element.n * element.molarMass / 1000);
                        this.createOrUpdateColumn(element, false);
                    }
                }
            }
        }

        checkEmpty(data) {
            if (data === "" || data === 0 || data === 0.00) {
                return true;
            }
            return false;
        }

        eqvCell(table, fragment, flagNew, index) {
            const eqvRow = table.rows[TABLE_ROWS.EQV];
            let eqvCell;
            if (flagNew) {
                eqvCell = eqvRow.insertCell(eqvRow.cells.length);
            } else {
                eqvCell = eqvRow.cells[index];
            }

            const eqvInput = document.createElement("input");
            eqvInput.type = "text";
            eqvInput.className = "eqv-input";

            if (fragment.flagReactant === true || fragment.action === true) {
                // Если фрагмент является реагентом, вводится эквивалент
                eqvInput.value = this.formatNumber(fragment.equivalent);
                const oldValue = fragment.equivalent;
                eqvInput.addEventListener('blur', (e) => {
                    if (this.validateProperty(e.target)) {
                        if (this.checkSimilar(eqvInput.value, fragment.equivalent)) {
                            eqvInput.value = this.formatNumber(fragment.equivalent);
                        } else {
                            fragment.equivalent = this.formatNumber(eqvInput.value);
                            eqvInput.value = this.formatNumber(eqvInput.value);
                            console.log("ProcessingOtherFieldsForEqv");
                            this.ProcessingOtherFieldsForEqv(oldValue, fragment);
                        }
                    } else {
                        fragment.equivalent = 1.00;
                        this.createOrUpdateColumn(fragment, false);
                        this.composer.sendDataToServerAsync();
                    }
                });
            } else {
                // Если фрагмент не является реагентом, вводится выход реакции
                const result = parseFloat((fragment.m / (this.activeFragment.n / 1000.0 * fragment.molarMass)) * 100.0);
                // мб this.activeFragment.n делить еще на эквивалент TO DO
                if (!isNaN(result) && isFinite(result)) {
                    eqvInput.value = result.toFixed(2);
                } else {
                    eqvInput.value = '';
                }

                if (fragment.action) {  //  TO DO
                    console.log("else if fragment.action");
                    eqvInput.disabled = false; // Делаем поле только для вывода информации
                } else {
                    console.log("else if fragment.action else");
                    eqvInput.disabled = true;
                }
            }

            eqvCell.innerHTML = '';
            eqvCell.appendChild(eqvInput);

        }

        ProcessingOtherFieldsForEqv(oldValue, fragmentInfo) {
            if (fragmentInfo.action === true) {
                var multiplier = fragmentInfo.equivalent / oldValue;
                this.createOrUpdateColumn(fragmentInfo, false);


                this.reactantFragments.forEach((value, key) => {
                    if (key !== fragmentInfo.fragmentId) {
                        value.m /= multiplier;
                        value.n /= multiplier;
                        this.createOrUpdateColumn(value, false);
                    }
                });

                this.productFragments.forEach((value, key) => {
                    if (key !== fragmentInfo.fragmentId) {
                        value.m /= multiplier;
                        value.n /= multiplier;
                        this.createOrUpdateColumn(value, false);
                    }
                });
            }
            if (fragmentInfo.flagReactant && fragmentInfo.action === false) {
                var multiplier = fragmentInfo.equivalent / oldValue;
                fragmentInfo.m *= multiplier;
                fragmentInfo.n *= multiplier;
                this.createOrUpdateColumn(fragmentInfo, false);
            }
            console.log("sendDataToServerAsync in ProcessingOtherFieldsForEqv");
            this.composer.sendDataToServerAsync();
        }


        checkSimilar(inputValue, value) {
            // console.log("checkSimilar", "1:", inputValue, "2:", value);
            if (parseFloat(inputValue) === parseFloat(value)) {
                // console.log("true");
                return true;
            } else {
                // console.log("false");
                return false;
            }
        }

        formatNumber(value) {
            if (/^\d+(\.\d+)?$/.test(value)) {
                return parseFloat(value).toFixed(2);
            } else {
                return value;
            }
        }

        multiplierUnit(fragment, flagM) {
            if (flagM) {
                if (fragment.mUnit === "мг") {
                    return 1000;
                }
                return 1;
            } else {
                if (fragment.nUnit === "моль") {
                    return 0.001;
                }
                return 1;
            }
        }

        validateProperty(inputElement) {
            var value = inputElement.value;
            if (this.isNumber(value)) {
                inputElement.style.color = 'black';
                return true;
            } else {
                inputElement.style.color = 'red';
                return false;
            }
        }

        isNumber(value) {
            return /^\d+(\.\d+)?$/.test(value);
        }

        createOrUpdateColumn(fragment, flagNew) {
            // console.log("in createOrUpdateColumn");
            const table = fragment.flagReactant ? this.tableReactant : this.tableProduct;
            let rowOffset = TABLE_ROWS.UNIQUE;

            if (flagNew) {
                // console.log("CREATE", fragment.fragmentId);
                this.formulaCell(fragment, table, fragment.formula, flagNew);
                this.mwCell(table, fragment.molarMass, flagNew);
                this.nCell(table, fragment, flagNew);
                this.mCell(table, fragment, flagNew);
                this.actionCell(table, fragment, flagNew);
                this.eqvCell(table, fragment, flagNew);

                const uniqueRow = table.rows[TABLE_ROWS.UNIQUE];

                let uniqueCell = uniqueRow.insertCell(uniqueRow.cells.length);
                uniqueCell.innerHTML = fragment.fragmentId;
            } else {
                for (let i = 1; i < table.rows[TABLE_ROWS.FORMULA].cells.length; i++) {
                    const cell = table.rows[rowOffset].cells[i];
                    const cellFragmentId = cell.innerHTML;

                    if (cellFragmentId === fragment.fragmentId) {
                        // console.log("UPDATE", fragment.fragmentId);
                        // console.log("cellFragmentId=", cellFragmentId, "fragment.fragmentId=", fragment.fragmentId);
                        this.formulaCell(fragment, table, fragment.formula, flagNew, i);
                        this.mwCell(table, fragment.molarMass, flagNew, i);
                        this.nCell(table, fragment, flagNew, i);
                        this.mCell(table, fragment, flagNew, i);
                        this.actionCell(table, fragment, flagNew);
                        this.eqvCell(table, fragment, flagNew, i);
                        break;
                    }

                }
            }
        }
    }

    class Fragment {
        constructor(id) {
            this.fragment = null;
            this.fragmentId = id;

            this.formula = "";
            this.molarMass = "";
            this.m = "";
            this.mUnit = "г";
            this.n = "";
            this.nUnit = "ммоль";
            this.equivalent = 1.00;
            this.action = false;
        }

        processFragment() {
            if (this.fragment.getNodeCount() === 0) {
                console.log(this.fragment.calcFormula().getText());
                return;
            }

            const molarMass = this.calculateMolarMass();

            const currMap = this.flagReactant ? this.table.reactantFragments : this.table.productFragments;
            const formula = this.fragment.calcFormula();

            const formulaText = this.parseFormula(formula.getText());


            const tableId = this.flagReactant ? "reactantTable" : "productTable";

            if (!currMap.has(this.fragmentId)) {
                this.formula = formulaText;
                this.molarMass = molarMass;
                if (this.table.reactantFragments.size + this.table.productFragments.size === 0) {
                    this.action = true;
                    this.table.activeFragment = this;
                }
                currMap.set(this.fragmentId, this);
                this.table.createOrUpdateColumn(this, true);

            } else if (molarMass !== currMap.get(this.fragmentId).molarMass) {
                this.formula = formulaText;
                this.molarMass = molarMass;
                this.table.createOrUpdateColumn(currMap.get(this.fragmentId), false);
            }
        }

        calculateMolarMass() {
            let totalMass = 0;
            for (let i = 0; i < this.fragment.getNodeCount(); ++i) {
                totalMass += this.processNode(this.fragment.getNodeAt(i));
            }
            return totalMass;
        }

        processNode(node) {
            let totalMass = 0;
            if (node instanceof Kekule.Atom || node instanceof Kekule.SubGroup) {
                totalMass += this.calculateFragmentMass(node);
                if (node instanceof Kekule.SubGroup) {
                    for (let i = 0; i < node.getNodeCount(); ++i) {
                        totalMass += this.processNode(node.getNodeAt(i)); // Рекурсивный вызов для обработки внутренних узлов
                    }
                }
            }
            return totalMass;
        }


        calculateFragmentMass(node) {
            let mass = 0;
            if (node instanceof Kekule.Atom) {
                if (node.getAtomicMass) {
                    mass += node.getAtomicMass();
                }
                if (node.getImplicitHydrogenCount) {
                    const hcount = node.getImplicitHydrogenCount() || 0;
                    mass += hcount * 1.00784;
                }
            }
            return mass;
        }

        parseFormula(inputString) {
            inputString = inputString.trim();
            const match = inputString.match(/([+-])$/);
            if (match) {
                inputString = inputString.slice(0, -2);
            }
            var result = "";
            var sign = '';
            var num = 1;
            for (var i = 0; i < inputString.length; i++) {
                if (inputString[i] !== ' ') {
                    result += inputString[i];
                } else {
                    if (i + 1 < inputString.length) {
                        if (!isNaN(inputString[i + 1])) {
                            num = 0;
                            while (i + 1 < inputString.length && !isNaN(inputString[i + 1])) {
                                num = num * 10 + parseInt(inputString[i + 1]);
                                i++;
                            }
                        }
                        if (inputString[i + 1] === '+') {
                            sign = '+';
                            i++;
                        } else if (inputString[i + 1] === '-') {
                            sign = '-';
                            i++;
                        }
                    }
                }
            }
            if (sign) {
                const chars = sign.repeat(num);
                result += chars;
            }
            return result;
        }
    }




    class Composer {
        constructor() {
            this.table = new Table(this);

            this.observedReactant = new Set();
            this.observedProduct = new Set();

            this.firstRun = true;

            
            this.initialize();
            
        }

        async initialize() {

            if (this.firstRun) {
                await this.addRepoItemAndUpdate();
            }

            this.firstRun = false;


            if (!targetComposer) {
                targetComposer = new Kekule.Editor.Composer(document.getElementById('composer'));
            }
            
            this.composer = targetComposer;
            this.composer.setChemToolButtons(['manipulate', 'erase', 'bond', 'atom', 'formula', 'ring', 'charge', 'glyph', 'textBlock']);

            this.removeAllColumnsExceptFirst();
            await this.getfile();

            this.composer.getEditor().on('operChange', this.eventHandler.bind(this));
            this.composer.getEditor().on('operUndo', this.eventHandler.bind(this));
            this.composer.getEditor().on('operRedo', this.eventHandler.bind(this));

            const newDocumentButton = document.querySelector('.K-Chem-NewDoc');

            newDocumentButton.addEventListener('click', this.removeAllColumnsExceptFirst.bind(this));
        }

        async getfile() {
            let id = @ViewBag.Id;
            try {
                let data = await $.ajax({
                    type: 'GET',
                    url: '/chemeditor/get_file/' + id,
                    contentType: 'application/json; charset=utf-8'
                });
                //console.log(data);
                this.displayData(data);
            } catch (error) {
                console.error('Произошла ошибка при получении данных химического редактора:', error);
            }
        }

        displayData(data) {
            if (data.chemDocumentData !== "") {
                //console.log("chemDocumentData:", data.chemDocumentData);
                let composer = this.composer;
                let chemData = Kekule.IO.loadFormatData(data.chemDocumentData, 'Kekule-JSON');
                composer.setChemObj(chemData);
                //  null
                if (data.XCoordinateArrow !== undefined && (!(Math.abs(data.XCoordinateArrow + 1.0) < 0.1))) {
                    this.xCoordinateArrow = data.xCoordinateArrow;
                    this.composer.setChemToolButtons(['manipulate', 'erase', 'bond', 'atom', 'formula', 'ring', 'charge', 'textBlock']);
                }

                // Очищаем текущие данные
                this.table.reactantFragments.clear();
                this.table.productFragments.clear();
               
                if (data && data.reactantData) {
                    data.reactantData.forEach(reactant => {                        
                        const fragment = new Fragment(reactant.fragmentId);
                        Object.assign(fragment, reactant); // Копируем свойства из reactant в fragment
                        fragment.table = this.table;
                        fragment.flagReactant = true;
                        this.table.reactantFragments.set(reactant.fragmentId, fragment);
                        if (fragment.action === true) {
                            this.table.activeFragment = fragment;
                        }
                        fragment.table.createOrUpdateColumn(fragment, true);
                    });
                }
                if (data && data.productData) {
                    data.productData.forEach(product => {
                        const fragment = new Fragment(product.fragmentId);
                        Object.assign(fragment, product); // Копируем свойства из reactant в fragment
                        fragment.table = this.table;
                        fragment.flagReactant = false;
                        this.table.productFragments.set(product.fragmentId, fragment);
                        if (fragment.action === true) {
                            this.table.activeFragment = fragment;
                        }
                        fragment.table.createOrUpdateColumn(fragment, true);
                    });
                }

                this.eventHandler();

                this.table.printFragmentIds();
            }
        }

        async sendDataToServerAsync() {
            // console.log("sendDataToServerAsync");
            try {
                let chemDocumentData = this.generateChemDocumentData();

                let XArrow = this.xCoordinateArrow || -1.0;


                let reactantFragmentsData = Array.from(this.table.reactantFragments.values()).map(fragment => ({
                    fragmentId: fragment.fragmentId,
                    formula: fragment.formula,
                    molarMass: parseFloat(fragment.molarMass),
                    m: parseFloat(fragment.m),
                    mUnit: fragment.mUnit,
                    n: parseFloat(fragment.n),
                    nUnit: fragment.nUnit,
                    equivalent: parseFloat(fragment.equivalent),
                    action: fragment.action
                }));

                let productFragmentsData = Array.from(this.table.productFragments.values()).map(fragment => ({
                    fragmentId: fragment.fragmentId,
                    formula: fragment.formula,
                    molarMass: parseFloat(fragment.molarMass),
                    m: parseFloat(fragment.m),
                    mUnit: fragment.mUnit,
                    n: parseFloat(fragment.n),
                    nUnit: fragment.nUnit,
                    equivalent: parseFloat(fragment.equivalent),
                    action: fragment.action
                }));

                let data = {
                    ChemDocumentData: chemDocumentData,
                    ReactantData: reactantFragmentsData,
                    ProductData: productFragmentsData,
                    XCoordinateArrow: XArrow
                };

                let id = @ViewBag.Id;
                // console.log('Отправка данных на сервер:', data);
                let response = await fetch('/chemeditor/save_data/' + id, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                });

                if (response.ok) {
                    if (response.status !== 204) { // Check if the response is not empty
                        let contentType = response.headers.get('content-type');
                        if (contentType && contentType.indexOf('application/json') !== -1) {
                            let responseData = await response.json();
                            // console.log('Данные успешно сохранены на сервере.', responseData);
                            return responseData;
                        } else {
                            // console.log('Данные успешно сохранены на сервере.');
                            return null;
                        }
                    } else {
                        // console.log('Данные успешно сохранены на сервере.');
                        return null;
                    }
                } else {
                    // console.error('Произошла ошибка при отправке данных на сервер:', response.statusText);
                    let errorText = await response.text();
                    console.error('Сообщение об ошибке сервера:', errorText);
                    throw new Error(response.statusText);
                }
            } catch (err) {
                // console.error('Произошла ошибка в sendDataToServerAsync:', err);
                throw err;
            }
        }

        generateChemDocumentData() {
            let ChemDocument = this.composer.exportObjs(Kekule.ChemDocument);
            let data = "";
            for (let i = 0, l = ChemDocument.length; i < l; ++i) {
                let part = ChemDocument[i];
                data += Kekule.IO.saveFormatData(part, 'Kekule-JSON');
            }
            //console.log(data);
            return data;
        }

        async eventHandler() {
            this.chemObj = this.composer.getChemObj();
            this.updateArrowState();

            this.observedReactant.clear();
            this.observedProduct.clear();

            var fragments = Kekule.ChemStructureUtils.getAllStructFragments(this.chemObj, true);

            if (fragments.length == 0) {
                this.removeAllColumnsExceptFirst();
            } else {

                for (var i = 0; i < fragments.length; i++) {
                    var currFragment = fragments[i];
                    currFragment.canonicalize();
                    const xArrow = this.xCoordinateArrow || null;
                    this.updateFragments(currFragment, xArrow);
                }
                this.deleteFragment(true);
                this.deleteFragment(false);
            }
            console.log("sendDataToServerAsync in eventHandler");
            await this.sendDataToServerAsync();
        }

        updateArrowState() {
            let arrows = this.composer.exportObjs(Kekule.Glyph.ReactionArrow);
            if (arrows.length > 0) {
                const objArrow = arrows[0];
                const coordX = objArrow.getCoord2D().x;
                const childCoordX = objArrow.getChildAt(0).getCoord2D().x;
                const currentXCoordinate = coordX + childCoordX;
                const storedXCoordinate = parseFloat(this.xCoordinateArrow);

                if (currentXCoordinate !== storedXCoordinate || !storedXCoordinate) {
                    this.xCoordinateArrow = currentXCoordinate;
                    this.composer.setChemToolButtons(['manipulate', 'erase', 'bond', 'atom', 'formula', 'ring', 'charge', 'textBlock']);
                }
            } else if (!document.querySelector('.K-Chem-ArrowLineIaController')) {
                this.composer.setChemToolButtons(['manipulate', 'erase', 'bond', 'atom', 'formula', 'ring', 'charge', 'glyph', 'textBlock']);
                this.xCoordinateArrow = null;
            }
        }

        updateFragments(currFragment, xArrow) {
            //console.log("in updateFragments");
            var fragmentId = currFragment.getId();
            var xCoordinateAtom = this.calculateAtomCoordinate(currFragment);
            if (xCoordinateAtom === null) {
                return; 
            }
            const isLeftOfArrow = xArrow === null || (xCoordinateAtom < xArrow);

            if (isLeftOfArrow) {
                this.observedReactant.add(fragmentId);
                if (!this.table.reactantFragments.has(fragmentId)) {
                    var fragment = new Fragment(fragmentId);
                    fragment.fragment = currFragment;
                    fragment.flagReactant = true;
                    fragment.table = this.table;
                } else {
                    var fragment = this.table.reactantFragments.get(fragmentId);
                    fragment.fragment = currFragment;
                    fragment.flagReactant = true;
                }
                fragment.processFragment();
            } else {
                this.observedProduct.add(fragmentId);
                if (!this.table.productFragments.has(fragmentId)) {
                    var fragment = new Fragment(fragmentId);
                    fragment.fragment = currFragment;
                    fragment.flagReactant = false;
                    fragment.table = this.table;
                } else {
                    var fragment = this.table.productFragments.get(fragmentId);
                    fragment.fragment = currFragment;
                    fragment.flagReactant = false;
                }
                fragment.processFragment();
            }
        }

        deleteFragment(flagReactant) {
            let flagSetAction = false;
            let columnsToDelete = [];

            const fragmentData = flagReactant ? this.table.reactantFragments : this.table.productFragments;
            const observedFragmentIds = flagReactant ? this.observedReactant : this.observedProduct;

            for (let existingFragmentId of fragmentData.keys()) {
                if (!observedFragmentIds.has(existingFragmentId)) {
                    columnsToDelete.push(existingFragmentId);
                }
            }

            if (columnsToDelete.length > 0) {
                const table = flagReactant ? this.table.tableReactant : this.table.tableProduct;

                for (let i = columnsToDelete.length - 1; i >= 0; i--) {
                    const fragmentId = columnsToDelete[i];

                    for (let j = 0; j < table.rows[TABLE_ROWS.UNIQUE].cells.length; j++) {
                        if (table.rows[TABLE_ROWS.UNIQUE].cells[j].innerHTML === fragmentId) {
                            for (let k = 0; k < table.rows.length; k++) {
                                table.rows[k].deleteCell(j);
                            }
                        }
                    }
                    if (fragmentData.get(fragmentId).action === true) {
                        flagSetAction = true;
                    }

                    fragmentData.delete(fragmentId);

                }
            }
            if (flagSetAction) {
                let fragmentIds;
                let firstFragmentId;

                const thisTable = flagReactant ? this.table.tableReactant : this.table.tableProduct;
                const anotherTable = flagReactant ? this.table.tableProduct : this.table.tableReactant;

                const anotherfragmentData = flagReactant ? this.table.productFragments : this.table.reactantFragments;
                if (fragmentData.size > 0) {
                    fragmentIds = Array.from(fragmentData.keys());
                    firstFragmentId = fragmentIds[0];
                    fragmentData.get(firstFragmentId).action = true;
                    this.table.activeFragment = fragmentData.get(firstFragmentId);

                    const radioButtons = thisTable.getElementsByClassName('action');
                    radioButtons[0].checked = true;
                } else if (anotherfragmentData.size > 0) {
                    fragmentIds = Array.from(anotherfragmentData.keys());
                    firstFragmentId = fragmentIds[0];
                    anotherfragmentData.get(firstFragmentId).action = true;
                    this.table.activeFragment = anotherfragmentData.get(firstFragmentId);

                    const radioButtons = anotherTable.getElementsByClassName('action');
                    radioButtons[0].checked = true;
                }
            }
        }

        calculateAtomCoordinate(currFragment) {
            if (currFragment && currFragment.getCoord2D()) {
                return currFragment.getCoord2D().x;
            } else if (currFragment && !currFragment.getCoord2D() && currFragment.getNodeAt(0) !== undefined) {
                var node = currFragment.getNodeAt(0);
                return node.getCoord2D().x;
            } else {
                return null;
            }
        }

        removeAllColumnsExceptFirst() {
            this.xCoordinateArrow = null;
            this.composer.setChemToolButtons(['manipulate', 'erase', 'bond', 'atom', 'formula', 'ring', 'charge', 'glyph', 'textBlock']);

            var table = this.table.tableReactant;
            for (var i = table.rows[0].cells.length - 1; i > 0; i--) {
                for (var j = 0; j < table.rows.length; j++) {
                    table.rows[j].deleteCell(i);
                }
            }
            this.table.reactantFragments.clear();

            var table = this.table.tableProduct;
            for (var i = table.rows[0].cells.length - 1; i > 0; i--) {
                for (var j = 0; j < table.rows.length; j++) {
                    table.rows[j].deleteCell(i);
                }
            }
            this.table.productFragments.clear();
        }

        async uploadMoleculeAsync(repItemData, info) {
            try {
                
                let data = {
                    Name: info.name,
                    Abbreviation: info.abbreviation,
                    FormulaText: info.formula,
                    InputTexts: info.text,
                    StructData: repItemData.structData
                };

                const response = await fetch('/chemeditor/upload_molecule', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                });

                if (response.ok) {
                    console.log('Молекула успешно загружена.');
                } else {
                    console.error('Произошла ошибка при загрузке молекулы:', response.statusText);
                }
            } catch (error) {
                console.error('Произошла ошибка при отправке данных на сервер:', error);
            }
        }

        async addRepoItemAndUpdate() {
            console.log("in addRepoItemAndUpdate");

            if (this.firstRun === true) {
                let molecules = await this.getMolecules();
                for (const molecule of molecules) {
                    var oldMolecule = Kekule.Editor.RepositoryItemManager.getItem(molecule.name);
                    if (oldMolecule) {
                        Kekule.Editor.RepositoryItemManager.unregister(oldMolecule);
                    }

                    Kekule.Editor.RepositoryData.subGroups.push(molecule);
                    var repItem = new Kekule.Editor.StoredSubgroupRepositoryItem2D(molecule.structData, molecule.dataFormat, molecule.scale);
                    repItem.setInputTexts(molecule.inputTexts).setName(molecule.name || molecule.inputTexts[0]);
                    Kekule.Editor.RepositoryItemManager.register(repItem);
                    await this.addRowToContent(molecule.name, molecule.abbreviation, molecule.formulaText, molecule.text, molecule.image);
                }
            }

            if (this.firstRun === false) {
                var nameValue = document.getElementById('editName').value.trim();
                var abbrValue = document.getElementById('editAbbr').value.trim();

                if (nameValue && abbrValue) {
                    var result = this.saveRepItemData();
                    var repItemData = result.obj;
                    var info = result.info;

                    var provStructData = repItemData.structData ? JSON.parse(repItemData.structData) : {};

                    if (provStructData.ctab === undefined) {
                        showErrorUnderButton();
                    } else {
                        var oldMolecule = Kekule.Editor.RepositoryItemManager.getItem(info.name);
                        if (oldMolecule) {
                            Kekule.Editor.RepositoryItemManager.unregister(oldMolecule);
                        }

                        await this.uploadMoleculeAsync(repItemData, info);

                        Kekule.Editor.RepositoryData.subGroups.push(repItemData);
                        var repItem = new Kekule.Editor.StoredSubgroupRepositoryItem2D(repItemData.structData, repItemData.dataFormat, repItemData.scale);
                        repItem.setInputTexts(repItemData.inputTexts).setName(repItemData.name || repItemData.inputTexts[0]);
                        Kekule.Editor.RepositoryItemManager.register(repItem);

                        await this.addRowToContent(info.name, info.abbreviation, info.formula, info.text);
                    }    
                }
            }
            
            if (targetComposer) {
                var composerDiv = document.getElementById('composer');
                while (composerDiv.firstChild) {
                    composerDiv.removeChild(composerDiv.firstChild);
                }
            }
            targetComposer = new Kekule.Editor.Composer(document.getElementById('composer'));
            if (this.firstRun === false && repItemData && repItemData.structData && repItemData.dataFormat) {
                targetComposer.load(repItemData.structData, repItemData.dataFormat);
            }
            this.composer = targetComposer;

        }

        async addRowToContent(name, abbreviation, formulaText, inputTexts, image) {
            const contentToToggle = document.getElementById('contentToToggle');

            const existingRows = contentToToggle.querySelectorAll('.molecule-row');
            existingRows.forEach(row => {
                if (row.querySelector('span').textContent === 'Name: ' + name) {
                    row.remove();
                }
            });

            const row = document.createElement('div');
            row.classList.add('molecule-row', 'hidden');

            this.addSpanToRow(row, 'Name: ' + name);
            this.addSeparatorToRow(row);
            this.addSpanToRow(row, 'Abbr: ' + abbreviation);
            if (formulaText) {
                this.addSeparatorToRow(row);
                this.addSpanToRow(row, 'Formula Text: ' + formulaText);
            }
            if (inputTexts) {
                this.addSeparatorToRow(row);
                this.addSpanToRow(row, 'Input Texts: ' + inputTexts);
            }

            if (image) {
                const img = document.createElement('img');
                img.src = 'data:image/png;base64,' + image;
                // img.classList.add('uploaded-image');
                img.classList.add('uploaded-image', 'hidden');


                const showHideButton = document.createElement('button');
                showHideButton.textContent = 'Show/Hide';
                showHideButton.classList.add('show-hide-button');
                showHideButton.addEventListener('click', () => {
                    img.classList.toggle('hidden');
                });

                img.addEventListener('click', async () => {
                    await this.uploadImage(row, name);
                });

                row.appendChild(img);
                row.appendChild(showHideButton);
            } else {
                const uploadButton = document.createElement('button');
                uploadButton.textContent = 'Upload Image';
                uploadButton.classList.add('upload-button');

                uploadButton.addEventListener('click', async () => {
                    await this.uploadImage(row, name);
                });

                row.appendChild(uploadButton);
            }

            const deleteButton = document.createElement('button');
            deleteButton.textContent = '❌';
            deleteButton.classList.add('delete-button');

            deleteButton.addEventListener('click', async () => {
                row.remove();
                await this.deleteMolecule(name);

                var oldMolecule = Kekule.Editor.RepositoryItemManager.getItem(name);
                if (oldMolecule) {
                    Kekule.Editor.RepositoryItemManager.unregister(oldMolecule);

                    if (targetComposer) {
                        var composerDiv = document.getElementById('composer');
                        while (composerDiv.firstChild) {
                            composerDiv.removeChild(composerDiv.firstChild);
                        }
                    }
                    targetComposer = new Kekule.Editor.Composer(document.getElementById('composer'));

                    await this.initialize();
                }
            });

            row.appendChild(deleteButton);

            contentToToggle.appendChild(row);
        }

        addSpanToRow(row, text) {
            const span = document.createElement('span');
            span.textContent = text;
            row.appendChild(span);
        }

        addSeparatorToRow(row) {
            const separator = document.createElement('span');
            separator.textContent = ' | ';
            row.appendChild(separator);
        }


        async uploadImage(row, name) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.addEventListener('change', async () => {
                const file = input.files[0];
                if (file) {
                    if (!file.type.startsWith('image/')) {
                        alert('Выбранный файл не является изображением.');
                        return;
                    }

                    const imageUrl = URL.createObjectURL(file);

                    const existingImage = row.querySelector('img.uploaded-image');
                    if (existingImage) {
                        existingImage.src = imageUrl;
                        await this.uploadImageToServer(file, name);
                    } else {
                        const image = document.createElement('img');
                        image.src = imageUrl;
                        image.classList.add('uploaded-image');

                        image.addEventListener('click', async () => {
                            await this.uploadImage(row);
                        });

                        const uploadButton = row.querySelector('.upload-button');
                        if (uploadButton) {
                            uploadButton.remove();
                        }

                        const showHideButton = document.createElement('button');
                        showHideButton.textContent = 'Show/Hide';
                        showHideButton.classList.add('show-hide-button');
                        showHideButton.addEventListener('click', () => {
                            image.classList.toggle('hidden');
                        });

                        row.appendChild(image);
                        row.appendChild(showHideButton);

                        await this.uploadImageToServer(file, name);
                    }
                }
            });
            input.click();
        }

        async uploadImageToServer(file, name) {
            const formData = new FormData();
            formData.append('image', file);

            try {
                
                const response = await fetch(`/chemeditor/UploadImage?name=${encodeURIComponent(name)}`, {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    console.log('Image uploaded successfully');
                } else {
                    console.error('Failed to upload image');
                }
            } catch (error) {
                console.error('Error occurred while uploading image:', error);
            }
        }

        async deleteMolecule(name) {
            console.log("deleteMolecule:", name);
            try {
                console.log("deleteMolecule:", name);
                const response = await fetch(`/chemeditor/DeleteMolecule?name=${encodeURIComponent(name)}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    console.log('Molecule deleted successfully');
                    
                } else {
                    const errorData = await response.json();
                    console.error('Error:', errorData.error);
                }
            } catch (error) {
                console.error('Error:', error);
            }
        }


        getRepObject() {
            var structClass = Kekule.Widget.getWidgetById('selStructType').getValue();
            var result = new structClass();
            var composer = Kekule.Widget.getWidgetById('composer');
            var srcObj = composer.exportObjs(Kekule.StructureFragment)[0];
            if (srcObj) {
                result.assign(srcObj, false);  // do not copy ids
            }
            var abbr = Kekule.Widget.getWidgetById('editAbbr').getValue();
            if (abbr && result.setAbbr) {
                result.setAbbr(abbr);
            }
            var formulaText = Kekule.Widget.getWidgetById('editFormulaText').getValue();
            if (formulaText && result.setFormulaText) {
                result.setFormulaText(formulaText);
            }

            // remove render options
            result.setRenderOptions(undefined);

            // translate coords
            result.setCoord2D({ 'x': 0, 'y': 0 });
            var objBox = Kekule.Render.ObjUtils.getContainerBox(result, Kekule.CoordMode.COORD2D, true);

            if (objBox) {
                var oldObjCoord = result.getCoordOfMode ?
                    result.getCoordOfMode(Kekule.CoordMode.COORD2D, true) || {} :
                    {};
                var delta = {};
                delta.x = -(objBox.x2 + objBox.x1) / 2;
                delta.y = -(objBox.y2 + objBox.y1) / 2;

                // transform coords of children
                result.beginUpdate();
                try {
                    for (var i = 0, l = result.getNodeCount(); i < l; ++i) {
                        var node = result.getNodeAt(i);
                        var coord = node.getAbsCoord2D(true);
                        coord = Kekule.CoordUtils.add(coord, delta);
                        node.setAbsCoord2D(coord);
                    }
                }
                finally {
                    result.endUpdate();
                }
            }
            return result;
        }

        setAnchorNodes() {
            var composer = Kekule.Widget.getWidgetById('composer');
            var selection = composer.getSelection();
            for (var i = 0, l = selection.length; i < l; ++i) {
                var obj = selection[i];
                if (obj.setIsAnchor)
                    obj.setIsAnchor(!obj.getIsAnchor());
            }
        }

        saveRepItemData() {
            var repObj = this.getRepObject();
            var obj = {};
            let info = {
                name: null,
                abbreviation: null,
                formula: null,
                text: null
            };

            var name = Kekule.Widget.getWidgetById('editName').getValue();
            if (name) {
                obj.name = name;
                info.name = name;
            }

            if (repObj instanceof Kekule.SubGroup) {
                var inputTexts = Kekule.Widget.getWidgetById('editInputTexts').getValue();
                if (inputTexts) {
                    info.text = inputTexts;
                    inputTexts = inputTexts.split('\n');
                    obj.inputTexts = inputTexts;
                } else {
                    obj.inputTexts = [];
                }

                if (repObj.getAbbr()) {
                    Kekule.ArrayUtils.pushUnique(obj.inputTexts, repObj.getAbbr());
                    info.abbreviation = repObj.getAbbr();
                }
                if (repObj.getFormulaText()) {
                    Kekule.ArrayUtils.pushUnique(obj.inputTexts, repObj.getFormulaText());
                    info.formula = repObj.getFormulaText();
                }
                if (repObj.getName()) {
                    obj.name = repObj.getName();
                    info.name = repObj.getName();
                }
            }
            
            var repObjData = Kekule.IO.saveFormatData(repObj, Kekule.IO.DataFormat.KEKULE_JSON);
            obj.dataFormat = Kekule.IO.DataFormat.KEKULE_JSON;
            obj.structData = repObjData;
            return { obj: obj, info: info };
        }

        async getMolecules() {
            try {
                let response = await fetch('/chemeditor/get_molecules');
                if (response.ok) {
                    let data = await response.json();
                    // console.log(data);

                    let molecules = data.map(item => {
                        let text = item.inputTexts;
                        let inputTexts = item.inputTexts.split('\n');
                        Kekule.ArrayUtils.pushUnique(inputTexts, item.abbreviation);
                        Kekule.ArrayUtils.pushUnique(inputTexts, item.formulaText);
                        Kekule.ArrayUtils.pushUnique(inputTexts, item.name);

 

                        let structDataString = item.structData.replace(/^"/, "'").replace(/"$/, "'");
                        structDataString = structDataString.replace(/\\"/g, '"');
                        structDataString = structDataString.slice(1, -1);



                        return {
                            abbreviation: item.abbreviation,
                            formulaText: item.formulaText,
                            text: text,
                            name: item.name,
                            structData: structDataString,
                            dataFormat: "Kekule-JSON",
                            inputTexts: inputTexts,
                            scale: undefined,
                            image: item.imageData
                        };
                    });
                    // console.log(molecules);
                    return molecules;

                } else {
                    console.error('Ошибка получения данных:', response.statusText);
                }
            } catch (error) {
                console.error('Произошла ошибка при получении данных:', error);
            }
        }

    }

    var targetComposer;

    function fillStructTypes() {  //  TO DO
        var selBox = Kekule.Widget.getWidgetById('selStructType');
        selBox.setItems([
            { 'text': 'Kekule.SubGroup', 'value': Kekule.SubGroup }
            // ,
            // {'text': 'Kekule.Molecule', 'value': Kekule.Molecule}
        ]);
    }

    async function init() {
        fillStructTypes();
        const myComposer = new Composer();

        Kekule.Widget.getWidgetById('btnSetAnchor').on('execute', function (e) {
            myComposer.setAnchorNodes();
        });
        Kekule.Widget.getWidgetById('btnAddRepoItem').on('execute', async function (e) {
            await myComposer.addRepoItemAndUpdate();
            await myComposer.initialize();
        });
    }


    Kekule.X.domReady(init);

</script>

<div>
    <a asp-action="Index">Назад на главную</a>
</div>
