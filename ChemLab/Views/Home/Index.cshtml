@model List<LabPracticeViewModel>
@{
    ViewData["Title"] = "Лабораторные опыты";
}
@if (User.Identity.IsAuthenticated)
{
    <div class="row">
        <h1 class="display-4 col-sm-2">@ViewData["Title"]</h1>
        <a class="col-sm-1 h4 offset-10" asp-controller="Home" asp-action="Create">Новый опыт</a>
    </div>
    <hr />
    <div>
        <input type="button" onclick="getfile()" value="btn" />
    </div>

    <div class="row">
        <div class="col-md-12">
            <table class="table">
                <thead>
                    <tr>
                        <th scope="col">Название</th>
                        <th scope="col">Дата создания</th>
                        <th scope="col">Описание</th>
                        <th scope="col">&nbsp;</th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var labPractice in Model)
                    {
                        <tr>
                            <td>@labPractice.Name</td>
                            <td>@labPractice.DateOfCreate</td>
                            <td>@labPractice.Description</td>
                            <td>
                                <a>Детали</a> |
                                <a>Редактировать</a> |
                                <a>Удалить</a>
                            </td>
                        </tr>
                    }
                </tbody>
            </table>
        </div>
    </div>

    <link rel="stylesheet" type="text/css" href="lib/libs/kekule/themes/default/kekule.css" />
    <style>
        p {
            margin: 0.3em 0.5em;
        }

        #composer {
            height: 450px;
            width: 600px;
            float: left;
        }

        .FloatClearer {
            clear: both;
        }

        .ChemViewer {
            width: 500px;
            height: 400px;
            border: 1px solid #ccc;
        }

        .data-grid {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .formula, .action, .molarMass, .mass, .mole {
            flex: 1;
            min-width: 0;
            text-align: center;
        }

        table {
            border-collapse: collapse;
            max-width: 600px; /* Максимальная ширина таблицы */
        }

        table, th, td {
            border: 1px solid black;
        }

        th, td {
            padding: 8px;
            text-align: center;
        }

        tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        #reactantTable tr:last-child {
            display: none;
        }

        #productTable tr:last-child {
            display: none;
        }

    </style>

    <div id="stage">
        <div id="composer" data-widget="Kekule.Editor.Composer" data-chem-obj="" data-resizable="true"></div>
        <div class="FloatClearer"></div>
    </div>

    <table id="reactantTable">
        <tr>
            <td>Формула</td>
        </tr>
        <tr>
            <td>MW</td>
        </tr>
        <tr>
            <td>m</td>
        </tr>
        <tr>
            <td>n</td>
        </tr>
        <tr>
            <td>Экв.</td>
        </tr>
        <tr>
            <td>Основной</td>
        </tr>
        <tr>
            <td><input type="hidden" name="uniqe" value="">
        </tr>
    </table>

    <table id="productTable">
        <tr>
            <td>Формула</td>
        </tr>
        <tr>
            <td>MW</td>
        </tr>
        <tr>
            <td>m</td>
        </tr>
        <tr>
            <td>n</td>
        </tr>
        <tr>
            <td>Экв.</td>
        </tr>
        <tr>
            <td><input type="hidden" name="uniqe" value="">
        </tr>
    </table>

    <script src="lib/libs/raphael-min.2.0.1.js"></script>
    <script src="lib/libs/kekule/kekule.js?modules=io,chemWidget"></script>
    <script>

        function parseServerData(data) {
            let parsedData = JSON.parse(data);

            let chemDocumentData = parsedData.ChemDocumentData; // строка

            let dataReactant = {}; // объект
            for (let i = 0; i < parsedData.ReactantData.length; i++) {
                let fragment = parsedData.ReactantData[i];
                dataReactant[fragment.fragmentId] = fragment;
            }

            let dataProduct = {}; // объект
            for (let i = 0; i < parsedData.ProductData.length; i++) {
                let fragment = parsedData.ProductData[i];
                dataProduct[fragment.fragmentId] = fragment;
            }

            // Возвращаем объект с разобранными данными
            return {
                ChemDocumentData: chemDocumentData,
                ReactantData: dataReactant,
                ProductData: dataProduct
            };
        }

        function getfile() {
            $.ajax({
                type: 'POST',
                url: 'chemeditor/get_file/123',
                data: '',
                contentType: 'application/json; charset=utf-8',
                success: function (data) {
                    let parsedData = parseServerData(data);
                    displayData(parsedData);

                },
                error: function (xhr, status, error) {
                    console.error('Произошла ошибка при отправке данных на сервер:', error);
                }
            });
        }

        function displayData(parsedData) {
            console.log(parsedData.ChemDocumentData);
            let composer = getComposer();
            let data = Kekule.IO.loadFormatData(parsedData.ChemDocumentData, 'Kekule-JSON');
            composer.setChemObj(data);
        }



        function getViewerDialog() {
            console.log("1!");
            var result = getViewerDialog._dialog;
            if (!result) {
                console.log("2!");
                result = new Kekule.Widget.Dialog(document, 'View', [Kekule.Widget.DialogButtons.OK]);
                result.setLocation(Kekule.Widget.Location.CENTER_OR_FULLFILL);
                var viewer = new Kekule.ChemWidget.Viewer(document, null, Kekule.Render.RendererType.R2D);
                viewer.addClassName('ChemViewer');
                viewer.setResizable(true);
                viewer.setPredefinedSetting('basic');
                viewer.appendToWidget(result);
                result._viewer = viewer;
                getViewerDialog._dialog = result;
            }
            return result;
        }

        function exportToViewer() {
            var dialog = getViewerDialog();
            dialog.openPopup();
            var viewer = dialog._viewer;
            var chemObj = getComposer().getChemObj();
            viewer.setChemObj(chemObj);
        }

        function updateColumn(fragmentId, updatedData, tableId, flagReactant, flagChangeMW) {
            var table = document.getElementById(tableId);
            //  убрать потом магические числа
            if (flagReactant) {
                var row = table.rows[6];
            } else {
                var row = table.rows[5];
            }
            for (var i = 1; i < row.cells.length; i++) {
                var cell = row.cells[i];
                var cellFragmentId = cell.innerHTML;
                if (cellFragmentId === fragmentId) {
                    var formulaCell = table.rows[0].cells[i];
                    formulaCell.innerHTML = updatedData.formula;

                    var mwCell = table.rows[1].cells[i];
                    mwCell.innerHTML = updatedData.molarMass;

                    var mCell = table.rows[2].cells[i];
                    var mInput = document.createElement("input");
                    mInput.type = "text";
                    mInput.className = "m-input";
                    // console.log("m-input", updatedData.m);
                    if (flagChangeMW) {
                        console.log("flagChangeMW==true", fragmentId);
                        if (updatedData.m !== "") {
                            mInput.value = (updatedData.n * updatedData.molarMass / 1000).toFixed(2);
                        }
                    } else {
                        console.log("flagChangeMW==false", fragmentId);
                        mInput.value = formatNumber(updatedData.m);
                    }

                    mCell.innerHTML = ''; // Очищаем содержимое ячейки
                    mCell.appendChild(mInput);
                    mInput.addEventListener('input', function (e) {
                        if (validateAndSetProperty(e.target, "m", updatedData)) {
                            ProcessingOtherFieldsForM(e.target.value, updatedData, tableId, flagReactant);
                        } else {
                            updatedData.m = "";
                        }
                    });

                    var nCell = table.rows[3].cells[i];
                    var nInput = document.createElement("input");
                    nInput.type = "text";
                    nInput.className = "n-input";
                    nInput.value = formatNumber(updatedData.n);

                    nCell.innerHTML = ''; // Очищаем содержимое ячейки
                    nCell.appendChild(nInput);
                    nInput.addEventListener('input', function (e) {
                        if (validateAndSetProperty(e.target, "n", updatedData)) {
                            ProcessingOtherFieldsForN(e.target.value, updatedData, tableId, flagReactant);
                        } else {
                            updatedData.n = "";
                        }
                    });

                    var eqvCell = table.rows[4].cells[i];
                    var eqvInput = document.createElement("input");
                    eqvInput.type = "text";
                    eqvInput.className = "eqv-input";
                    eqvInput.value = formatNumber(updatedData.equivalent);
                    eqvCell.innerHTML = ''; // Очищаем содержимое ячейки
                    eqvCell.appendChild(eqvInput);
                    var oldValue = eqvInput.value;
                    eqvInput.addEventListener('input', function (e) {
                        if (validateAndSetProperty(e.target, "equivalent", updatedData)) {
                            ProcessingOtherFieldsForEqv(oldValue, updatedData, tableId, flagReactant);
                        } else {
                            updatedData.equivalent = 1.00;
                        }
                    });

                    break; // Выйти из цикла, как только ячейка будет обновлена
                }
            }
        }

        function createColumn(fragmentInfo, tableId, flagReactant) {
            var table = document.getElementById(tableId);
            //  убрать потом магические числа
            var formulaRow = table.rows[0];
            var mwRow = table.rows[1];
            var mRow = table.rows[2];
            var nRow = table.rows[3];
            var eqvRow = table.rows[4];

            if (flagReactant) {
                var actionRow = table.rows[5];
                var uniqeRow = table.rows[6];
            } else {
                var uniqeRow = table.rows[5];
            }


            var formulaCell = formulaRow.insertCell(formulaRow.cells.length);
            formulaCell.innerHTML = fragmentInfo.formula;

            var mwCell = mwRow.insertCell(mwRow.cells.length);
            mwCell.innerHTML = fragmentInfo.molarMass;

            let flagFullnes = false;
            var resFullness = checkForFullness();
            if (resFullness) {
                var nValueBase = resFullness.n;
                var eqvValueBase = resFullness.equivalent;
                flagFullnes = true;
            }

            var nCell = nRow.insertCell(nRow.cells.length);
            var nInput = document.createElement("input");
            nInput.type = "text";
            nInput.className = "n-input";
            if (flagFullnes) {
                fragmentInfo.n = (nValueBase / eqvValueBase).toFixed(2);;
                nInput.value = formatNumber(fragmentInfo.n);
            } else {
                nInput.value = "";
            }
            nCell.appendChild(nInput);
            nInput.addEventListener('input', function (e) {
                if (validateAndSetProperty(e.target, "n", fragmentInfo)) {
                    ProcessingOtherFieldsForN(e.target.value, fragmentInfo, tableId, flagReactant);
                } else {
                    fragmentInfo.n = "";
                }
            });

            var mCell = mRow.insertCell(mRow.cells.length);
            var mInput = document.createElement("input");
            mInput.type = "text";
            mInput.className = "m-input";
            if (flagFullnes) {
                fragmentInfo.m = (fragmentInfo.n * fragmentInfo.molarMass / 1000).toFixed(2);
                mInput.value = formatNumber(fragmentInfo.m);
            } else {
                mInput.value = "";
            }
            mCell.appendChild(mInput);
            mInput.addEventListener('input', function (e) {
                if (validateAndSetProperty(e.target, "m", fragmentInfo)) {
                    ProcessingOtherFieldsForM(e.target.value, fragmentInfo, tableId, flagReactant);
                } else {
                    fragmentInfo.m = "";
                }
            });

            var eqvCell = eqvRow.insertCell(eqvRow.cells.length);
            var eqvInput = document.createElement("input");
            eqvInput.type = "text";
            eqvInput.className = "eqv-input";
            eqvInput.value = formatNumber(fragmentInfo.equivalent);
            eqvCell.appendChild(eqvInput);
            var oldValue = eqvInput.value;
            eqvInput.addEventListener('input', function (e) {
                if (validateAndSetProperty(e.target, "equivalent", fragmentInfo)) {
                    ProcessingOtherFieldsForEqv(oldValue, fragmentInfo, tableId, flagReactant);
                } else {
                    fragmentInfo.equivalent = 1.00;
                }
            });
            if (flagReactant) {

                var actionCell = actionRow.insertCell(actionRow.cells.length);
                var radioInput = document.createElement("input");
                radioInput.type = 'radio';
                radioInput.name = 'action';
                radioInput.className = 'action';

                if (fragmentInfo.action == 1) {
                    radioInput.checked = true;
                }

            radioInput.addEventListener('change', function () {
                fragmentInfo.action = 1;
                resetAllActionsExcept(fragmentInfo.fragmentId);
            });

                actionCell.appendChild(radioInput);

            }

            var uniqeCell = uniqeRow.insertCell(uniqeRow.cells.length);
            uniqeCell.innerHTML = fragmentInfo.fragmentId;
        }

        function checkForFullness() {
            var reactionElementWithAction = Object.values(reactantData).find(elem => elem.action === 1);
            if (reactionElementWithAction && reactionElementWithAction.n !== "" && reactionElementWithAction.m !== "") {
                // return reactionElementWithAction.n;
                return {
                    n: reactionElementWithAction.n,
                    equivalent: reactionElementWithAction.equivalent
                };
            } else {
                for (var key in productData) {
                    var productElement = productData[key];
                    if (productElement.n !== "" && productElement.m !== "") {
                        return {
                            n: productElement.n,
                            equivalent: productElement.equivalent
                        };
                    }
                }
                return null;
            }
        }

        function resetAllActionsExcept(fragmentId) {
            var keys = Object.keys(reactantData);
            for (var i = 0; i < keys.length; i++) {
                var elem = reactantData[keys[i]];

                if (elem.fragmentId !== fragmentId) {
                    elem.action = 0;
                }
                console.log(elem.fragmentId, elem.action);
            }
        }



        function formatNumber(value) {
            if (/^\d+(\.\d+)?$/.test(value)) {
                return parseFloat(value).toFixed(2);
            } else {
                return value;
            }
        }

        function isNumber(value) {
            return /^\d+(\.\d+)?$/.test(value);
        }

        function validateAndSetProperty(inputElement, property, fragmentInfo) {
            var value = inputElement.value;
            inputElement.value = value;
            if (isNumber(value)) {
                fragmentInfo[property] = value;
                console.log("valid true");
                return true;
            } else {
                console.log("valid false");
                inputElement.style.color = 'red';
                return false;
            }
        }

        function ProcessingOtherFieldsForM(value, fragmentInfo, tableId, flagReactant) {
            var mValue = value;
            var newNvalue = (mValue / fragmentInfo.molarMass * 1000).toFixed(2);
            fragmentInfo.n = newNvalue;
            updateColumn(fragmentInfo.fragmentId, fragmentInfo, tableId, flagReactant, false);

            if (!(flagReactant && fragmentInfo.action === 0)) {

                for (var key in reactantData) {
                    if (key !== fragmentInfo.fragmentId) {
                        reactantData[key].m = (reactantData[key].molarMass / fragmentInfo.molarMass * fragmentInfo.m * reactantData[key].equivalent / fragmentInfo.equivalent).toFixed(2);
                        reactantData[key].n = (reactantData[key].m / reactantData[key].molarMass * 1000).toFixed(2);
                        updateColumn(key, reactantData[key], "reactantTable", true, false);
                    }
                }
                for (var key in productData) {
                    if (key !== fragmentInfo.fragmentId) {
                        productData[key].m = (productData[key].molarMass / fragmentInfo.molarMass * fragmentInfo.m * productData[key].equivalent / fragmentInfo.equivalent).toFixed(2);
                        productData[key].n = (productData[key].m / productData[key].molarMass * 1000).toFixed(2);
                        updateColumn(key, productData[key], "productTable", false, false);
                    }
                }
            }

        }

        function ProcessingOtherFieldsForN(value, fragmentInfo, tableId, flagReactant) {

            var nValue = value;
            var newMvalue = (nValue * fragmentInfo.molarMass / 1000).toFixed(2);
            fragmentInfo.m = newMvalue;
            updateColumn(fragmentInfo.fragmentId, fragmentInfo, tableId, flagReactant, false);

            if (!(flagReactant && fragmentInfo.action === 0)) {

                for (var key in reactantData) {
                    if (key !== fragmentInfo.fragmentId) {
                        reactantData[key].n = (reactantData[key].equivalent / fragmentInfo.equivalent * fragmentInfo.n).toFixed(2);
                        reactantData[key].m = (reactantData[key].n * reactantData[key].molarMass / 1000).toFixed(2);
                        updateColumn(key, reactantData[key], "reactantTable", true, false);
                    }
                }
                for (var key in productData) {
                    if (key !== fragmentInfo.fragmentId) {
                        productData[key].n = (productData[key].equivalent / fragmentInfo.equivalent * fragmentInfo.n).toFixed(2);
                        productData[key].m = (productData[key].n * productData[key].molarMass / 1000).toFixed(2);
                        updateColumn(key, productData[key], "productTable", false, false);
                    }
                }

            }

        }

        function ProcessingOtherFieldsForEqv(oldValue, fragmentInfo, tableId, flagReactant) {
            // console.log("fragmentInfo.equivalent / oldValue = ", fragmentInfo.equivalent, "*", oldValue, "=", fragmentInfo.equivalent / oldValue);

            if (flagReactant && fragmentInfo.action === 1) {
                var multiplier = fragmentInfo.equivalent / oldValue;
                updateColumn(fragmentInfo.fragmentId, fragmentInfo, tableId, flagReactant, false);
                for (var key in reactantData) {
                    if (key !== fragmentInfo.fragmentId) {
                        console.log("multiplier", multiplier);
                        reactantData[key].m /= multiplier;
                        reactantData[key].n /= multiplier;
                        updateColumn(key, reactantData[key], tableId, true, false);
                    }
                }
                for (var key in productData) {
                    // if (key !== fragmentInfo.fragmentId) {
                    console.log("multiplier", multiplier);
                    productData[key].m /= multiplier;
                    productData[key].n /= multiplier;
                    updateColumn(key, productData[key], "productTable", false, false);
                    // }
                }
            } else {
                var multiplier = fragmentInfo.equivalent / oldValue;
                fragmentInfo.m *= multiplier;
                fragmentInfo.n *= multiplier;
                updateColumn(fragmentInfo.fragmentId, fragmentInfo, tableId, flagReactant, false);
            }
        }


        function getComposer() {
            return Kekule.Widget.getWidgetById('composer');
        }


        function calculateMolecularMass(formulaText) {
            var molarMass = 0;
            var currentElement = "";
            var currentMultiplier = 1;

            for (var i = 0; i < formulaText.length; i++) {
                var char = formulaText[i];
                if (isNaN(char)) {
                    currentElement += char;
                    if (i + 1 < formulaText.length && formulaText[i + 1] > 'a' && formulaText[i + 1] < 'z') {
                        char = formulaText[i + 1];
                        currentElement += char;
                        i++;
                    }
                    var atomInfo = Kekule.ChemicalElementsDataUtil.getElementInfo(currentElement);
                    if (atomInfo) {
                        if (i + 1 < formulaText.length && !isNaN(formulaText[i + 1])) {
                            currentMultiplier = parseInt(formulaText[i + 1]);
                            i++;
                            while (i + 1 < formulaText.length && !isNaN(formulaText[i + 1])) {
                                currentMultiplier = currentMultiplier * 10 + parseInt(formulaText[i + 1]);
                                i++;
                            }
                        }
                        molarMass += atomInfo.naturalMass * currentMultiplier;
                    }
                    currentElement = "";
                    currentMultiplier = 1;
                }
            }
            molarMass = molarMass.toFixed(2);
            return molarMass;;
        }

        var reactantData = {};
        var productData = {};

        function init() {
            localStorage.removeItem('xCoordinateArrow');
            var composer = getComposer();

            composer.setChemToolButtons(['manipulate', 'erase', 'bond', 'atom', 'formula', 'ring', 'charge', 'glyph', 'textBlock']);

            composer.getEditor().on('operChange', handleOperationChangeOrUndo);
            composer.getEditor().on('operUndo', handleOperationChangeOrUndo);
            composer.getEditor().on('operRedo', handleOperationChangeOrUndo);

            var newDocumentButton = document.querySelector('.K-Chem-NewDoc');

            newDocumentButton.addEventListener('click', removeAllColumnsExceptFirst);

        }

        function handleOperationChangeOrUndo(e) {
            var composer = getComposer();
            var chemObj = composer.getChemObj();

            var arrows = composer.exportObjs(Kekule.Glyph.StraightLine);
            var xOffset = 1.2;
            if ((arrows.length > 0 && !localStorage.getItem('xCoordinateArrow')) ||
                (arrows.length > 0 && arrows[0].__$coord2D.x + xOffset !== parseFloat(localStorage.getItem('xCoordinateArrow')))) {
                // console.log("arrow");
                var xCoordinateArrow = arrows[0].__$coord2D.x + xOffset;
                localStorage.setItem('xCoordinateArrow', xCoordinateArrow);
                // console.log(xCoordinateArrow);
                composer.setChemToolButtons(['manipulate', 'erase', 'bond', 'atom', 'formula', 'ring', 'charge', 'textBlock']);
            } else if (!(arrows.length > 0)) {
                composer.setChemToolButtons(['manipulate', 'erase', 'bond', 'atom', 'formula', 'ring', 'charge', 'glyph', 'textBlock']);
                localStorage.removeItem('xCoordinateArrow');
            }


            var fragments = Kekule.ChemStructureUtils.getAllStructFragments(chemObj, true);
            // console.log(fragments);
            // console.log(fragments.length);

            if (fragments.length == 0) {
                removeAllColumnsExceptFirst();
            } else {
                var observedFragmentIdsReactant = {};
                var observedFragmentIdsProduct = {};
                for (var i = 0; i < fragments.length; i++) {
                    var fragment = fragments[i];
                    var fragmentId = fragment.__$id;

                    if (fragment && fragment.__$coord2D) {
                        var node = fragment.getNodeAt(0);
                        var xCoordinateAtom = fragment.__$coord2D.x;
                        // console.log("X atom=", xCoordinateAtom);
                    } else if (fragment && !fragment.__$coord2D) {
                        var node = fragment.getNodeAt(0);
                        var xCoordinateAtom = node.__$coord2D.x;
                        // console.log("X atom=", xCoordinateAtom);
                    }

                    var xCoordinateArrow = localStorage.getItem('xCoordinateArrow') || 0;
                    // console.log(fragmentId);
                    var flagReactant = true;
                    // console.log("true", fragmentId);
                    if (xCoordinateArrow === 0 || (xCoordinateArrow !== 0 && xCoordinateAtom < xCoordinateArrow)) {
                        observedFragmentIdsReactant[fragmentId] = true;
                        processFragment(reactantData, fragments, fragment, fragmentId, "reactantTable", flagReactant);
                    } else {
                        observedFragmentIdsProduct[fragmentId] = true;
                        processFragment(productData, fragments, fragment, fragmentId, "productTable", !flagReactant);
                    }
                }

                // if (flagToDelete && fragments.length > 0) {

                deleteFragment(reactantData, "reactantTable", observedFragmentIdsReactant, flagReactant);
                deleteFragment(productData, "productTable", observedFragmentIdsProduct, !flagReactant);
                // }
            }


        }

        function deleteFragment(fragmentData, tableId, observedFragmentIds, flagReactant) {

            var flagSetAction = false;
            var columnsToDelete = [];

            for (var existingFragmentId in fragmentData) {
                if (!observedFragmentIds[existingFragmentId]) {
                    columnsToDelete.push(existingFragmentId);
                }
            }
            if (columnsToDelete.length > 0) {
                var tmp = 5;  //  магические числа
                if (flagReactant) {
                    tmp = 6;
                }
                // Удаляем столбцы из таблицы в обратном порядке
                var table = document.getElementById(tableId);
                for (var i = columnsToDelete.length - 1; i >= 0; i--) {
                    var fragmentId = columnsToDelete[i];
                    for (var j = 0; j < table.rows[tmp].cells.length; j++) {
                        if (table.rows[tmp].cells[j].innerHTML === fragmentId) {
                            for (var k = 0; k < table.rows.length; k++) {
                                table.rows[k].deleteCell(j);
                            }
                        }
                    }
                    if (flagReactant && Object.keys(fragmentData).length > 1 && fragmentData[fragmentId].action === 1) {
                        flagSetAction = true;
                    }
                    // Удаляем fragmentData
                    console.log("delete", fragmentId);
                    delete fragmentData[fragmentId];
                }
            }
            if (flagReactant && flagSetAction) {
                // console.log("update selection");
                var fragmentIds = Object.keys(fragmentData);
                var firstFragmentId = fragmentIds[0];
                fragmentData[firstFragmentId].action = 1;
                var radioButtons = document.getElementsByClassName('action');
                radioButtons[0].checked = true;
            }
        }

        function processFragment(fragmentData, fragments, fragment, fragmentId, tableId, flagReactant) {
            if (!fragmentData[fragmentId]) {

                var formula = fragment.calcFormula();
                var formulaText = formula.getText();
                var molarMass = calculateMolecularMass(formulaText);

                fragmentData[fragmentId] = {
                    fragment: fragment,
                    fragmentId: fragmentId,
                    formula: formulaText,
                    molarMass: molarMass,
                    m: "",
                    n: "",
                    equivalent: 1.00,
                    action: 0
                };
                console.log("add new", fragmentId, flagReactant, Object.keys(fragmentData).length);
                if (Object.keys(fragmentData).length == 1 && flagReactant) {
                    fragmentData[fragmentId].action = 1;
                }
                createColumn(fragmentData[fragmentId], tableId, flagReactant);
                // flagToDelete = false;
            } else {
                if (fragmentData[fragmentId].formula !== (fragment.calcFormula()).getText()) {
                    console.log("update", fragmentId, flagReactant);
                    var formula = fragment.calcFormula();
                    var formulaText = formula.getText();
                    var molarMass = calculateMolecularMass(formulaText);

                    fragmentData[fragmentId].formula = formulaText;
                    fragmentData[fragmentId].molarMass = molarMass;
                    updateColumn(fragmentId, fragmentData[fragmentId], tableId, flagReactant, true);
                    // flagToDelete = false;
                }
            }
            sendDataToServer();
        }

        function disp() {
            var keys = Object.keys(reactantData);
            for (var i = 0; i < keys.length; i++) {
                var elem = reactantData[keys[i]];

                console.log(elem.fragmentId, elem.action);
            }
        }

        function removeAllColumnsExceptFirst() {
            var composer = getComposer();
            localStorage.clear();
            composer.setChemToolButtons(['manipulate', 'erase', 'bond', 'atom', 'formula', 'ring', 'charge', 'glyph', 'textBlock']);
            var table = document.getElementById("reactantTable");
            for (var i = table.rows[0].cells.length - 1; i > 0; i--) {
                for (var j = 0; j < table.rows.length; j++) {
                    table.rows[j].deleteCell(i);
                }
            }
            reactantData = {};
            var table = document.getElementById("productTable");
            for (var i = table.rows[0].cells.length - 1; i > 0; i--) {
                for (var j = 0; j < table.rows.length; j++) {
                    table.rows[j].deleteCell(i);
                }
            }
            productData = {};
        }

        function sendDataToServer() {
            let chemDocumentData = generateChemDocumentData();
            let chemNumbersData = generateChemNumbersData();

            dataReactant = chemNumbersData.reactantArray;
            dataProduct = chemNumbersData.productArray;

            let dataContainer = {
                ChemDocumentData: chemDocumentData,
                ReactantData: dataReactant,
                ProductData: dataProduct
            };

            $.ajax({
                type: 'POST',
                url: 'chemeditor/save_data',
                data: JSON.stringify(dataContainer),
                contentType: 'application/json; charset=utf-8',
                success: function (data) {
                    console.log('Данные успешно сохранены на сервере.');
                },
                error: function (xhr, status, error) {
                    console.error('Произошла ошибка при отправке данных на сервер:', error);
                }
            });
        }

        function generateChemDocumentData() {
            let ChemDocument = getComposer().exportObjs(Kekule.ChemDocument);
            let data = "";
            for (let i = 0, l = ChemDocument.length; i < l; ++i) {
                let part = ChemDocument[i];
                data += Kekule.IO.saveFormatData(part, 'Kekule-JSON');
            }
            console.log(data);
            return data;
        }

        function generateChemNumbersData() {
            let reactantArray = [];
            let productArray = [];

            for (let fragmentId in reactantData) {
                let fragment = reactantData[fragmentId];
                reactantArray.push({
                    fragmentId: fragmentId,
                    formula: fragment.formula,
                    molarMass: fragment.molarMass,
                    m: fragment.m,
                    n: fragment.n,
                    equivalent: fragment.equivalent,
                    action: fragment.action
                });
            }

            for (let fragmentId in productData) {
                let fragment = productData[fragmentId];
                productArray.push({
                    fragmentId: fragmentId,
                    formula: fragment.formula,
                    molarMass: fragment.molarMass,
                    m: fragment.m,
                    n: fragment.n,
                    equivalent: fragment.equivalent,
                    action: fragment.action
                });
            }

            return { reactantArray, productArray };
        }

        Kekule.X.domReady(init);

    </script>
}