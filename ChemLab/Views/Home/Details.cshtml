@model ChemLab.Data.Entity.LabPractice

@{
    ViewData["Title"] = "Details";
}

<h1 class="display-4">@ViewData["Title"]</h1>
<hr />

<link rel="stylesheet" type="text/css" href="~/lib/libs/dist/themes/default/kekule.css" />


<style>
    p {
        margin: 0.3em 0.5em;
    }

    #composer {
        height: 450px;
        width: 600px;
        float: left;
    }

    .FloatClearer {
        clear: both;
    }

    .ChemViewer {
        width: 500px;
        height: 400px;
        border: 1px solid #ccc;
    }

    .data-grid {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .formula, .action, .molarMass, .mass, .mole {
        flex: 1;
        min-width: 0;
        text-align: center;
    }

    table {
        border-collapse: collapse;
        max-width: 600px; /* Максимальная ширина таблицы */
    }

    table, th, td {
        border: 1px solid black;
    }

    th, td {
        padding: 8px;
        text-align: center;
    }

    tr:nth-child(even) {
        background-color: #f2f2f2;
    }

    #reactantTable tr:last-child {
        display: none;
    }

    #productTable tr:last-child {
        display: none;
    }

    .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5); /* Полупрозрачный черный фон */
    }

    /* Стили для контента внутри модального окна */
    .modal-content {
        background-color: #fefefe;
        margin: 15% auto;
        padding: 20px;
        border: 1px solid #888;
        width: 80%;
        max-width: 600px;
        text-align: center;
    }

        /* Стили для кнопки закрытия */
        .modal-content button {
            margin-top: 10px;
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

</style>

<div id="stage">
    <div id="composer" data-widget="Kekule.Editor.Composer"
         data-chem-obj="" data-resizable="true"></div>
    <div class="FloatClearer"></div>
</div>

<table id="reactantTable">
    <tr>
        <td>Формула</td>
    </tr>
    <tr>
        <td>MW</td>
    </tr>
    <tr>
        <td>m</td>
    </tr>
    <tr>
        <td>n</td>
    </tr>
    <tr>
        <td>Экв.</td>
    </tr>
    <tr>
        <td>Основной</td>
    </tr>
    <tr>
        <td><input type="hidden" name="uniqe" value="">
    </tr>
</table>

<table id="productTable">
    <tr>
        <td>Формула</td>
    </tr>
    <tr>
        <td>MW</td>
    </tr>
    <tr>
        <td>m</td>
    </tr>
    <tr>
        <td>n</td>
    </tr>
    <tr>
        <td>Экв.</td>
    </tr>
    <tr>
        <td><input type="hidden" name="uniqe" value="">
    </tr>
</table>


<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CAS Number Lookup</title>
<script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>

<script src="~/lib/libs/raphael-min.2.0.1.js"></script>
<script src="~/lib/libs/dist/kekule.js?"></script>

<img id="infoImage" src="~/info.png" alt="Информация" style="width: 20px; height: 20px;">

<script>

    var reactantData = {};
    var productData = {};

    function displayData(parsedData) {
        if (parsedData.chemDocumentData !== "") {
            let composer = getComposer();
            let data = Kekule.IO.loadFormatData(parsedData.chemDocumentData, 'Kekule-JSON');
            composer.setChemObj(data);

            // console.log("parsedData.reactantData:", parsedData.reactantData);

            if (data.xCoordinateArrow !== undefined && (!(Math.abs(data.xCoordinateArrow + 1.0) < 0.1))) {
                //console.log("SET xCoordinateArrow", data.xCoordinateArrow);
                //console.log(!(Math.abs(data.xCoordinateArrow + 1.0) < 0.1));
                localStorage.setItem('xCoordinateArrow', data.xCoordinateArrow);
                let composer = getComposer();
                composer.setChemToolButtons(['manipulate', 'erase', 'bond', 'atom', 'formula', 'ring', 'charge', 'textBlock']);

            }

            reactantData = JSON.parse(parsedData.reactantData);
            productData = JSON.parse(parsedData.productData);

            let chemObj = getComposer().getChemObj();
            var fragments = Kekule.ChemStructureUtils.getAllStructFragments(chemObj, true);


            for (var i = 0; i < fragments.length; i++) {
                var fragment = fragments[i];
                var fragmentId = fragment.__$__k__p__id;
                if (reactantData.hasOwnProperty(fragmentId)) {
                    reactantData[fragmentId].fragment = fragment;
                    createColumn(reactantData[fragmentId], "reactantTable", true);
                } else if (productData.hasOwnProperty(fragmentId)) {
                    productData[fragmentId].fragment = fragment;
                    createColumn(productData[fragmentId], "productTable", false);
                }
            }

        }
    }


    async function getfile() {
        console.log("GET FILE");
        let id = @ViewBag.Id;
        try {
            let data = await $.ajax({
                type: 'GET',
                url: '/chemeditor/get_file/' + id,
                contentType: 'application/json; charset=utf-8'
            });
            // console.log("xCoordinateArrow", data.xCoordinateArrow);


            displayData(data);
        } catch (error) {
            console.error('Произошла ошибка при получении данных химического редактора:', error);
        }
    }


    function openInfoWindowWithChemInfo(smiles, formula) {
        try {
            var modal = document.createElement("div");
            modal.className = "modal";
            var modalContent = document.createElement("div");
            modalContent.className = "modal-content";

            var formulaText = document.createElement("p");
            formulaText.innerText = "Дополнительная информация о " + formula;
            modalContent.appendChild(formulaText);

            var loadingText = document.createElement("p");
            loadingText.innerText = "Идет загрузка данных...";
            modalContent.appendChild(loadingText);

            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            modal.style.display = "block";

            getChemInfoFromServer(smiles)
                .then((chemInfo) => {
                    loadingText.style.display = "none";

                    if (chemInfo) {
                        var casNumberText = document.createElement("p");
                        casNumberText.innerText = "CAS Number: " + chemInfo.casNumber;
                        modalContent.appendChild(casNumberText);

                        var firstSynonymText = document.createElement("p");
                        firstSynonymText.innerText = "Имя: " + chemInfo.firstSynonym;
                        modalContent.appendChild(firstSynonymText);

                        var image = document.createElement("img");
                        image.src = "data:image/png;base64," + chemInfo.imageDataUrl;
                        modalContent.appendChild(image);
                    } else {
                        var errorText = document.createElement("p");
                        errorText.innerText = "Не удалось найти информацию";
                        modalContent.appendChild(errorText);
                    }

                    var closeButton = document.createElement("button");
                    closeButton.innerText = "Закрыть";
                    closeButton.addEventListener("click", function () {
                        modal.style.display = "none";
                    });
                    modalContent.appendChild(closeButton);
                })
                .catch((error) => {
                    console.error('Ошибка:', error.message);
                });
        } catch (error) {
            console.error('Ошибка:', error.message);
        }
    }


    function updateColumn(fragmentId, updatedData, tableId, flagReactant, flagChangeMW) {
        var table = document.getElementById(tableId);
        //  убрать потом магические числа
        // console.log("Updated mass for", fragmentId, "|", updatedData.m);
        if (flagReactant) {
            var row = table.rows[6];
        } else {
            var row = table.rows[5];
        }
        for (var i = 1; i < row.cells.length; i++) {
            var cell = row.cells[i];
            var cellFragmentId = cell.innerHTML;
            if (cellFragmentId === fragmentId) {

                /////////////////////////////////////////////////////////

                var formulaCell = table.rows[0].cells[i];
                formulaCell.innerHTML = updatedData.formula;

                var infoImage = document.getElementById("infoImage");

                var infoButton = document.createElement("button");
                infoButton.type = "button";
                infoButton.style.border = "none";
                infoButton.style.padding = "0";
                infoButton.style.backgroundColor = "transparent";
                infoButton.style.marginLeft = "5px";

                var clonedImage = infoImage.cloneNode(true);
                infoButton.appendChild(clonedImage);

                infoButton.addEventListener("click", function () {
                    var smiles = Kekule.IO.saveFormatData(updatedData.fragment, 'smi');
                    // console.log("smiles", smiles);
                    // console.log("updatedData.formula", updatedData.formula);
                    openInfoWindowWithChemInfo(smiles, updatedData.formula);
                });

                formulaCell.appendChild(infoButton);

                /////////////////////////////////////////////////////////

                var mwCell = table.rows[1].cells[i];
                mwCell.innerHTML = (updatedData.molarMass).toFixed(2);

                var mCell = table.rows[2].cells[i];

                var mInput = document.createElement("input");
                mInput.type = "text";
                mInput.className = "m-input";
                // console.log("m-input", updatedData.m);
                if (flagChangeMW) {
                    // console.log("flagChangeMW==true", fragmentId);
                    if (updatedData.m !== "") {
                        mInput.value = (updatedData.n * updatedData.molarMass / 1000 * multiplierUnit(updatedData, true)).toFixed(2);
                    }
                } else {
                    // console.log("flagChangeMW==false", fragmentId);
                    mInput.value = formatNumber(updatedData.m * multiplierUnit(updatedData, true));
                }

                mCell.innerHTML = ''; // Очищаем содержимое ячейки
                mCell.appendChild(mInput);
                mInput.addEventListener('blur', function (e) {
                    if (validateAndSetProperty(e.target, "m", updatedData)) {
                        ProcessingOtherFieldsForM(e.target.value, updatedData, tableId, flagReactant);
                    } else {
                        updatedData.m = "";
                    }
                });

                var mUnitSelect = document.createElement("select");
                mUnitSelect.className = "m-unit-select";
                var options = ["г", "мг"];
                for (let i = 0; i < options.length; i++) {
                    var option = document.createElement("option");
                    option.value = options[i];
                    option.text = options[i];
                    if (updatedData.mUnit === "мг" && options[i] === "мг") {
                        option.selected = true;
                    } else if (updatedData.mUnit === "г" && options[i] === "г") {
                        option.selected = true;
                    }
                    mUnitSelect.appendChild(option);
                }
                mCell.appendChild(mUnitSelect);

                mUnitSelect.addEventListener('change', function (e) {
                    if (handleMUnitChange(e, mInput, updatedData, true)) {
                        mInput.value = formatNumber(updatedData.m * 1000);
                    } else {
                        mInput.value = formatNumber(updatedData.m);
                    }
                    updateColumn(fragmentId, updatedData, tableId, flagReactant, flagChangeMW);

                });

                var nCell = table.rows[3].cells[i];
                var nInput = document.createElement("input");
                nInput.type = "text";
                nInput.className = "n-input";
                nInput.value = formatNumber(updatedData.n * multiplierUnit(updatedData, false));

                nCell.innerHTML = ''; // Очищаем содержимое ячейки
                nCell.appendChild(nInput);
                nInput.addEventListener('blur', function (e) {
                    if (validateAndSetProperty(e.target, "n", updatedData)) {
                        ProcessingOtherFieldsForN(e.target.value, updatedData, tableId, flagReactant);
                    } else {
                        updatedData.n = "";
                    }
                });
                //console.log("ninput:", nInput.value, "updatedData.n", updatedData.n);
                var nUnitSelect = document.createElement("select");
                nUnitSelect.className = "n-unit-select";
                var options = ["моль", "ммоль"];
                for (let i = 0; i < options.length; i++) {
                    var option = document.createElement("option");
                    option.value = options[i];
                    option.text = options[i];
                    if (updatedData.nUnit === "моль" && options[i] === "моль") {
                        option.selected = true;
                    } else if (updatedData.nUnit === "ммоль" && options[i] === "ммоль") {
                        option.selected = true;
                    }
                    nUnitSelect.appendChild(option);
                }
                nCell.appendChild(nUnitSelect);
                nUnitSelect.addEventListener('change', function (e) {
                    if (handleMUnitChange(e, nInput, updatedData, false)) {
                        nInput.value = formatNumber(updatedData.n / 1000);
                    } else {
                        nInput.value = formatNumber(updatedData.n);
                    }
                    updateColumn(fragmentId, updatedData, tableId, flagReactant, flagChangeMW);
                });

                var eqvCell = table.rows[4].cells[i];
                var eqvInput = document.createElement("input");
                eqvInput.type = "text";
                eqvInput.className = "eqv-input";
                eqvInput.value = formatNumber(updatedData.equivalent);
                eqvCell.innerHTML = ''; // Очищаем содержимое ячейки
                eqvCell.appendChild(eqvInput);
                var oldValue = eqvInput.value;
                eqvInput.addEventListener('blur', function (e) {
                    if (validateAndSetProperty(e.target, "equivalent", updatedData)) {
                        ProcessingOtherFieldsForEqv(oldValue, updatedData, tableId, flagReactant);
                    } else {
                        updatedData.equivalent = 1.00;
                        updateColumn(updatedData.fragmentId, updatedData, tableId, flagReactant, false);
                    }
                });

                break; // Выйти из цикла, как только ячейка будет обновлена
            }
        }
    }

    function createColumn(fragmentInfo, tableId, flagReactant) {
        var table = document.getElementById(tableId);

        // console.log("Create mass for", fragmentInfo.fragmentId, "|", fragmentInfo.m);
        //  убрать потом магические числа
        var formulaRow = table.rows[0];
        var mwRow = table.rows[1];
        var mRow = table.rows[2];
        var nRow = table.rows[3];
        var eqvRow = table.rows[4];

        if (flagReactant) {
            var actionRow = table.rows[5];
            var uniqeRow = table.rows[6];
        } else {
            var uniqeRow = table.rows[5];
        }


        var formulaCell = formulaRow.insertCell(formulaRow.cells.length);
        formulaCell.innerHTML = fragmentInfo.formula;

        var infoImage = document.getElementById("infoImage");

        var infoButton = document.createElement("button");
        infoButton.type = "button";
        infoButton.style.border = "none";
        infoButton.style.padding = "0";
        infoButton.style.backgroundColor = "transparent";
        infoButton.style.marginLeft = "5px";

        var clonedImage = infoImage.cloneNode(true);
        infoButton.appendChild(clonedImage);

        infoButton.addEventListener("click", function () {
            var smiles = Kekule.IO.saveFormatData(fragmentInfo.fragment, 'smi');
            // console.log("smiles", smiles);
            // console.log("formula", fragmentInfo.formula);
            openInfoWindowWithChemInfo(smiles, fragmentInfo.formula);
        });

        formulaCell.appendChild(infoButton);



        /////////////////////////////////////////////////////////////////////////

        var mwCell = mwRow.insertCell(mwRow.cells.length);
        mwCell.innerHTML = (fragmentInfo.molarMass).toFixed(2);

        let flagFullnes = false;
        var resFullness = checkForFullness();
        if (resFullness) {
            var nValueBase = resFullness.n;
            var eqvValueBase = resFullness.equivalent;
            flagFullnes = true;
        }

        /////////////////////////////////////////////////////////////////////////

        var nCell = nRow.insertCell(nRow.cells.length);
        var nInput = document.createElement("input");
        nInput.type = "text";
        nInput.className = "n-input";
        if (flagFullnes) {
            fragmentInfo.n = (nValueBase / eqvValueBase);
            nInput.value = formatNumber(fragmentInfo.n * multiplierUnit(fragmentInfo, false));
        } else {
            nInput.value = "";
        }
        nCell.appendChild(nInput);
        nInput.addEventListener('blur', function (e) {
            if (validateAndSetProperty(e.target, "n", fragmentInfo)) {
                ProcessingOtherFieldsForN(e.target.value, fragmentInfo, tableId, flagReactant);
            } else {
                fragmentInfo.n = "";
            }
        });

        var nUnitSelect = document.createElement("select");
        nUnitSelect.className = "n-unit-select";
        var options = ["моль", "ммоль"];
        for (let i = 0; i < options.length; i++) {
            var option = document.createElement("option");
            option.value = options[i];
            option.text = options[i];
            if (fragmentInfo.nUnit === "моль" && options[i] === "моль") {
                option.selected = true;
            } else if (fragmentInfo.nUnit === "ммоль" && options[i] === "ммоль") {
                option.selected = true;
            }
            nUnitSelect.appendChild(option);
        }
        nCell.appendChild(nUnitSelect);
        nUnitSelect.addEventListener('change', function (e) {
            if (handleMUnitChange(e, nInput, fragmentInfo, false)) {
                nInput.value = formatNumber(fragmentInfo.n / 1000);
            } else {
                nInput.value = formatNumber(fragmentInfo.n);
            }
            updateColumn(fragmentInfo.fragmentId, fragmentInfo, tableId, flagReactant, false);
        });

        /////////////////////////////////////////////////////////////////////////

        var mCell = mRow.insertCell(mRow.cells.length);
        var mInput = document.createElement("input");
        mInput.type = "text";
        mInput.className = "m-input";
        if (flagFullnes) {
            fragmentInfo.m = (fragmentInfo.n * fragmentInfo.molarMass / 1000);
            mInput.value = formatNumber(fragmentInfo.m * multiplierUnit(fragmentInfo, true));
        } else {
            mInput.value = "";
        }
        mCell.appendChild(mInput);
        mInput.addEventListener('blur', function (e) {
            if (validateAndSetProperty(e.target, "m", fragmentInfo)) {
                ProcessingOtherFieldsForM(e.target.value, fragmentInfo, tableId, flagReactant);
            } else {
                fragmentInfo.m = "";
            }
        });

        var mUnitSelect = document.createElement("select");
        mUnitSelect.className = "m-unit-select";
        var options = ["г", "мг"];
        for (let i = 0; i < options.length; i++) {
            var option = document.createElement("option");
            option.value = options[i];
            option.text = options[i];
            if (fragmentInfo.mUnit === "мг" && options[i] === "мг") {
                option.selected = true;
            } else if (fragmentInfo.mUnit === "г" && options[i] === "г") {
                option.selected = true;
            }
            mUnitSelect.appendChild(option);
        }
        mCell.appendChild(mUnitSelect);
        mUnitSelect.addEventListener('change', function (e) {
            if (handleMUnitChange(e, mInput, fragmentInfo, true)) {
                mInput.value = formatNumber(fragmentInfo.m * 1000);
            } else {
                mInput.value = formatNumber(fragmentInfo.m);
            }
            updateColumn(fragmentInfo.fragmentId, fragmentInfo, tableId, flagReactant, false);
        });

        /////////////////////////////////////////////////////////////////////////

        var eqvCell = eqvRow.insertCell(eqvRow.cells.length);
        var eqvInput = document.createElement("input");
        eqvInput.type = "text";
        eqvInput.className = "eqv-input";
        eqvInput.value = formatNumber(fragmentInfo.equivalent);
        eqvCell.appendChild(eqvInput);
        var oldValue = eqvInput.value;
        eqvInput.addEventListener('blur', function (e) {
            if (validateAndSetProperty(e.target, "equivalent", fragmentInfo)) {
                ProcessingOtherFieldsForEqv(oldValue, fragmentInfo, tableId, flagReactant);
            } else {
                fragmentInfo.equivalent = 1.00;
            }
        });

        /////////////////////////////////////////////////////////////////////////

        if (flagReactant) {

            var actionCell = actionRow.insertCell(actionRow.cells.length);
            var radioInput = document.createElement("input");
            radioInput.type = 'radio';
            radioInput.name = 'action';
            radioInput.className = 'action';

            if (fragmentInfo.action == 1) {
                radioInput.checked = true;
            }

            radioInput.addEventListener('change', () => {
                fragmentInfo.action = 1;
                resetAllActionsExcept(fragmentInfo.fragmentId);
                if (fragmentInfo.n !== "" && fragmentInfo.m !== "") {
                    updateEmptyFields(reactantData, fragmentInfo, "reactantTable", true);
                    updateEmptyFields(productData, fragmentInfo, "productTable", false);
                }
            });

            actionCell.appendChild(radioInput);

        }

        /////////////////////////////////////////////////////////////////////////

        var uniqeCell = uniqeRow.insertCell(uniqeRow.cells.length);
        uniqeCell.innerHTML = fragmentInfo.fragmentId;
    }

    function handleMUnitChange(e, mInput, fragment, flagM) {
        var selectedUnit = e.target.value;
        if (flagM) {
            if (selectedUnit === "мг") {
                fragment.mUnit = "мг";
                return true;
            } else if (selectedUnit === "г") {
                fragment.mUnit = "г";
                return false;
            }
        } else {
            if (selectedUnit === "моль") {
                fragment.nUnit = "моль";
                return true;
            } else if (selectedUnit === "ммоль") {
                fragment.nUnit = "ммоль";
                return false;
            }
        }

    }



    function updateEmptyFields(data, actvieFragment, tableId, flagReactant) {
        for (var key in data) {
            var element = data[key];
            if (element.action === 0) {
                if (element.n === "" && element.m === "") {
                    element.n = actvieFragment.n * element.equivalent / actvieFragment.equivalent;
                    element.m = (element.n * element.molarMass / 1000);
                    updateColumn(key, element, tableId, flagReactant, false);
                } else if (element.n === "") {
                    element.n = (element.m / element.molarMass * 1000);
                    updateColumn(key, element, tableId, flagReactant, false);
                } else if (element.m === "") {
                    element.m = (element.n * element.molarMass / 1000);
                    updateColumn(key, element, tableId, flagReactant, false);
                }
            }
        }
    }

    function checkForFullness() {
        var reactionElementWithAction = Object.values(reactantData).find(elem => elem.action === 1);
        if (reactionElementWithAction && reactionElementWithAction.n !== "" && reactionElementWithAction.m !== "") {
            return {
                n: reactionElementWithAction.n,
                equivalent: reactionElementWithAction.equivalent
            };
        } else {
            for (var key in productData) {
                var productElement = productData[key];
                if (productElement.n !== "" && productElement.m !== "") {
                    return {
                        n: productElement.n,
                        equivalent: productElement.equivalent
                    };
                }
            }
            return null;
        }
    }

    function resetAllActionsExcept(fragmentId) {
        var keys = Object.keys(reactantData);
        for (var i = 0; i < keys.length; i++) {
            var elem = reactantData[keys[i]];

            if (elem.fragmentId !== fragmentId) {
                elem.action = 0;
            }
            // console.log(elem.fragmentId, elem.action);
        }
    }



    function formatNumber(value) {
        if (/^\d+(\.\d+)?$/.test(value)) {
            return parseFloat(value).toFixed(2);
        } else {
            return value;
        }
    }

    function isNumber(value) {
        return /^\d+(\.\d+)?$/.test(value);
    }

    function validateAndSetProperty(inputElement, property, fragmentInfo) {
        var value = inputElement.value;
        inputElement.value = value;
        if (isNumber(value)) {
            fragmentInfo[property] = value;
            // console.log("valid true");
            return true;
        } else {
            // console.log("valid false");
            inputElement.style.color = 'red';
            return false;
        }
    }

    function multiplierUnit(fragment, flagM) {
        if (flagM) {
            if (fragment.mUnit === "мг") {
                return 1000;
            }
            return 1;
        } else {
            if (fragment.nUnit === "моль") {
                return 0.001;
            }
            return 1;
        }
    }

    function ProcessingOtherFieldsForM(value, fragmentInfo, tableId, flagReactant) {
        var mValue = value / multiplierUnit(fragmentInfo, true);
        var newNvalue = (mValue / fragmentInfo.molarMass * 1000);
        fragmentInfo.n = newNvalue;
        fragmentInfo.m = mValue;
        updateColumn(fragmentInfo.fragmentId, fragmentInfo, tableId, flagReactant, false);

        if (!(flagReactant && fragmentInfo.action === 0)) {

            for (var key in reactantData) {
                if (key !== fragmentInfo.fragmentId) {
                    reactantData[key].m = (reactantData[key].molarMass / fragmentInfo.molarMass * fragmentInfo.m * reactantData[key].equivalent / fragmentInfo.equivalent);
                    reactantData[key].n = (reactantData[key].m / reactantData[key].molarMass * 1000);
                    updateColumn(key, reactantData[key], "reactantTable", true, false);
                }
            }
            for (var key in productData) {
                if (key !== fragmentInfo.fragmentId) {
                    productData[key].m = (productData[key].molarMass / fragmentInfo.molarMass * fragmentInfo.m * productData[key].equivalent / fragmentInfo.equivalent);
                    productData[key].n = (productData[key].m / productData[key].molarMass * 1000);
                    updateColumn(key, productData[key], "productTable", false, false);
                }
            }
        }
    }

    function ProcessingOtherFieldsForN(value, fragmentInfo, tableId, flagReactant) {

        var nValue = value / multiplierUnit(fragmentInfo, false);
        console.log("ProcessingOtherFieldsForNNNN", nValue);
        var newMvalue = (nValue * fragmentInfo.molarMass / 1000);
        fragmentInfo.n = nValue;
        fragmentInfo.m = newMvalue;
        updateColumn(fragmentInfo.fragmentId, fragmentInfo, tableId, flagReactant, false);

        if (!(flagReactant && fragmentInfo.action === 0)) {

            for (var key in reactantData) {
                if (key !== fragmentInfo.fragmentId) {
                    reactantData[key].n = (reactantData[key].equivalent / fragmentInfo.equivalent * fragmentInfo.n);
                    reactantData[key].m = (reactantData[key].n * reactantData[key].molarMass / 1000);
                    updateColumn(key, reactantData[key], "reactantTable", true, false);
                }
            }
            for (var key in productData) {
                if (key !== fragmentInfo.fragmentId) {
                    productData[key].n = (productData[key].equivalent / fragmentInfo.equivalent * fragmentInfo.n);
                    productData[key].m = (productData[key].n * productData[key].molarMass / 1000);
                    updateColumn(key, productData[key], "productTable", false, false);
                }
            }

        }
    }

    function ProcessingOtherFieldsForEqv(oldValue, fragmentInfo, tableId, flagReactant) {
        if (flagReactant && fragmentInfo.action === 1) {
            var multiplier = fragmentInfo.equivalent / oldValue;
            updateColumn(fragmentInfo.fragmentId, fragmentInfo, tableId, flagReactant, false);
            for (var key in reactantData) {
                if (key !== fragmentInfo.fragmentId) {
                    // console.log("multiplier", multiplier);
                    reactantData[key].m /= multiplier;
                    reactantData[key].n /= multiplier;
                    updateColumn(key, reactantData[key], tableId, true, false);
                }
            }
            for (var key in productData) {
                // console.log("multiplier", multiplier);
                productData[key].m /= multiplier;
                productData[key].n /= multiplier;
                updateColumn(key, productData[key], "productTable", false, false);
            }
        } else {
            var multiplier = fragmentInfo.equivalent / oldValue;
            fragmentInfo.m *= multiplier;
            fragmentInfo.n *= multiplier;
            updateColumn(fragmentInfo.fragmentId, fragmentInfo, tableId, flagReactant, false);
        }
    }

    function getComposer() {
        return Kekule.Widget.getWidgetById('composer');
    }


    async function getChemInfoFromServer(smiles) {
        try {
            const response = await fetch(`/api/pubchem/get_cas/${encodeURIComponent(smiles)}`);

            if (!response.ok) {
            }

            const data = await response.json();

            if (data.success) {
                const casNumber = data.casNumber;
                const firstSynonym = data.firstSynonym;
                const imageDataUrl = data.image;

                return { casNumber, firstSynonym, imageDataUrl };
            } else {
                return null;
            }
        } catch (error) {
            return null;
        }
    }
   
    async function init() {

        localStorage.removeItem('xCoordinateArrow');
        var composer = getComposer();
        composer.setChemToolButtons(['manipulate', 'erase', 'bond', 'atom', 'formula', 'ring', 'charge', 'glyph', 'textBlock']);

        await getfile();

        composer.getEditor().on('operChange', handleOperationChangeOrUndo);
        composer.getEditor().on('operUndo', handleOperationChangeOrUndo);
        composer.getEditor().on('operRedo', handleOperationChangeOrUndo);

        var newDocumentButton = document.querySelector('.K-Chem-NewDoc');

        newDocumentButton.addEventListener('click', removeAllColumnsExceptFirst);

    }

    async function handleOperationChangeOrUndo(e) {
        var composer = getComposer();
        var chemObj = composer.getChemObj();

        var arrows = composer.exportObjs(Kekule.Glyph.ReactionArrow);
        var xOffset = 1.2;

        if ((arrows.length > 0 && !localStorage.getItem('xCoordinateArrow')) ||
            (arrows.length > 0 && arrows[0].__$__k__p__coord2D.x + xOffset !== parseFloat(localStorage.getItem('xCoordinateArrow')))) {
            var xCoordinateArrow = arrows[0].__$__k__p__coord2D.x + xOffset;
            localStorage.setItem('xCoordinateArrow', xCoordinateArrow);
            composer.setChemToolButtons(['manipulate', 'erase', 'bond', 'atom', 'formula', 'ring', 'charge', 'textBlock']);
        } else if (!(arrows.length > 0)) {
            if (document.querySelector('.K-Chem-ArrowLineIaController') == null) {
                composer.setChemToolButtons(['manipulate', 'erase', 'bond', 'atom', 'formula', 'ring', 'charge', 'glyph', 'textBlock']);
                localStorage.removeItem('xCoordinateArrow');
            }
        }

        var fragments = Kekule.ChemStructureUtils.getAllStructFragments(chemObj, true);

        if (fragments.length == 0) {
            removeAllColumnsExceptFirst();
        } else {
            var observedFragmentIdsReactant = {};
            var observedFragmentIdsProduct = {};

            for (var i = 0; i < fragments.length; i++) {
                var fragment = fragments[i];
                var fragmentId = fragment.__$__k__p__id;


                if (fragment && fragment.__$__k__p__coord2D) {
                    var node = fragment.getNodeAt(0);
                    var xCoordinateAtom = fragment.__$__k__p__coord2D.x;
                } else if (fragment && !fragment.__$__k__p__coord2D) {
                    var node = fragment.getNodeAt(0);
                    var xCoordinateAtom = node.__$__k__p__coord2D.x;
                }

                var xCoordinateArrow = localStorage.getItem('xCoordinateArrow') || 0;
                var flagReactant = true;

                if (xCoordinateArrow === 0 || (xCoordinateArrow !== 0 && xCoordinateAtom < xCoordinateArrow)) {
                    observedFragmentIdsReactant[fragmentId] = true;
                    await processFragment(reactantData, fragments, fragment, fragmentId, "reactantTable", flagReactant);
                } else {
                    observedFragmentIdsProduct[fragmentId] = true;
                    await processFragment(productData, fragments, fragment, fragmentId, "productTable", !flagReactant);
                }
            }

            deleteFragment(reactantData, "reactantTable", observedFragmentIdsReactant, flagReactant);
            deleteFragment(productData, "productTable", observedFragmentIdsProduct, !flagReactant);
        }

        await sendDataToServerAsync();

        // console.log('Данные успешно отправлены на сервер.');
    }


    function deleteFragment(fragmentData, tableId, observedFragmentIds, flagReactant) {
        var flagSetAction = false;
        var columnsToDelete = [];

        for (var existingFragmentId in fragmentData) {
            if (!observedFragmentIds[existingFragmentId]) {
                columnsToDelete.push(existingFragmentId);
            }
        }
        if (columnsToDelete.length > 0) {
            var tmp = 5;  //  магические числа
            if (flagReactant) {
                tmp = 6;
            }
            // Удаляем столбцы из таблицы в обратном порядке
            var table = document.getElementById(tableId);

            for (var i = columnsToDelete.length - 1; i >= 0; i--) {
                var fragmentId = columnsToDelete[i];

                for (var j = 0; j < table.rows[tmp].cells.length; j++) {
                    if (table.rows[tmp].cells[j].innerHTML === fragmentId) {
                        for (var k = 0; k < table.rows.length; k++) {
                            table.rows[k].deleteCell(j);
                        }
                    }
                }

                if (flagReactant && Object.keys(fragmentData).length > 1 && fragmentData[fragmentId].action === 1) {
                    flagSetAction = true;
                }

                delete fragmentData[fragmentId];
            }
        }

        if (flagReactant && flagSetAction) {
            var fragmentIds = Object.keys(fragmentData);
            var firstFragmentId = fragmentIds[0];
            fragmentData[firstFragmentId].action = 1;

            var radioButtons = document.getElementsByClassName('action');
            radioButtons[0].checked = true;
        }

    }


    async function processFragment(fragmentData, fragments, fragment, fragmentId, tableId, flagReactant) {
        var totalMass = 0;

        for (var i = 0, l = fragment.getNodeCount(); i < l; ++i) {
            var node = fragment.getNodeAt(i);

            if (node.getAtomicMass) {
                totalMass += node.getAtomicMass();
            }

            if (node.getImplicitHydrogenCount) {
                var hcount = node.getImplicitHydrogenCount() || 0;
                totalMass += hcount * 1.01;
            }
        }

        var molarMass = totalMass;

        if (!fragmentData[fragmentId]) {
            var formula = fragment.calcFormula();
            var formulaText = parseFormula(formula.getText());

            fragmentData[fragmentId] = {
                fragment: fragment,
                fragmentId: fragmentId,
                formula: formulaText,
                molarMass: molarMass,
                m: "",
                mUnit: "г",
                n: "",
                nUnit: "ммоль",
                equivalent: 1.00,
                action: 0
            };

            if (Object.keys(fragmentData).length == 1 && flagReactant) {
                fragmentData[fragmentId].action = 1;
            }

            createColumn(fragmentData[fragmentId], tableId, flagReactant);
        } else if (fragmentData[fragmentId].formula !== parseFormula((fragment.calcFormula()).getText())) {
            var formula = fragment.calcFormula();
            var formulaText = parseFormula(formula.getText());

            fragmentData[fragmentId].formula = formulaText;
            fragmentData[fragmentId].molarMass = molarMass;
            updateColumn(fragmentId, fragmentData[fragmentId], tableId, flagReactant, true);
        }
    }


    function parseFormula(inputString) {
        inputString = inputString.trim();
        const match = inputString.match(/([+-])$/);
        if (match) {
            inputString = inputString.slice(0, -2);
        }
        var result = "";
        var sign = '';
        var num = 1;
        for (var i = 0; i < inputString.length; i++) {
            if (inputString[i] !== ' ') {
                result += inputString[i];
            } else {
                if (i + 1 < inputString.length) {
                    if (!isNaN(inputString[i + 1])) {
                        num = 0;
                        while (i + 1 < inputString.length && !isNaN(inputString[i + 1])) {
                            num = num * 10 + parseInt(inputString[i + 1]);
                            i++;
                        }
                    }
                    if (inputString[i + 1] === '+') {
                        sign = '+';
                        i++;
                    } else if (inputString[i + 1] === '-') {
                        sign = '-';
                        i++;
                    }
                }

            }
        }
        if (sign) {
            const chars = sign.repeat(num);
            result += chars;
        }

        return result;
    }

    function removeAllColumnsExceptFirst() {
        var composer = getComposer();
        localStorage.clear();
        composer.setChemToolButtons(['manipulate', 'erase', 'bond', 'atom', 'formula', 'ring', 'charge', 'glyph', 'textBlock']);
        var table = document.getElementById("reactantTable");
        for (var i = table.rows[0].cells.length - 1; i > 0; i--) {
            for (var j = 0; j < table.rows.length; j++) {
                table.rows[j].deleteCell(i);
            }
        }
        reactantData = {};
        var table = document.getElementById("productTable");
        for (var i = table.rows[0].cells.length - 1; i > 0; i--) {
            for (var j = 0; j < table.rows.length; j++) {
                table.rows[j].deleteCell(i);
            }
        }
        productData = {};
    }

    async function sendDataToServerAsync() {
        try {
            let chemDocumentData = generateChemDocumentData();
            let chemNumbersData = generateChemNumbersData();

            let dataReactant = chemNumbersData.reactantObject || {};
            let dataProduct = chemNumbersData.productObject || {};

            let XArrow = parseFloat(localStorage.getItem('xCoordinateArrow')) || -1.0;

            let dataContainer = {
                ChemDocumentData: chemDocumentData,
                ReactantData: JSON.stringify(dataReactant),
                ProductData: JSON.stringify(dataProduct),
                xCoordinateArrow: XArrow
            };

            let id = @ViewBag.Id;

            // console.log('Отправка данных на сервер:', dataContainer);

            let response = await fetch('/chemeditor/save_data/' + id, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(dataContainer)
            });

            if (response.ok) {
                if (response.status !== 204) { // Check if the response is not empty
                    let contentType = response.headers.get('content-type');
                    if (contentType && contentType.indexOf('application/json') !== -1) {
                        let responseData = await response.json();
                        // console.log('Данные успешно сохранены на сервере.', responseData);
                        return responseData;
                    } else {
                        // console.log('Данные успешно сохранены на сервере.');
                        return null;
                    }
                } else {
                    // console.log('Данные успешно сохранены на сервере.');
                    return null;
                }
            } else {
                // console.error('Произошла ошибка при отправке данных на сервер:', response.statusText);
                let errorText = await response.text();
                // console.error('Сообщение об ошибке сервера:', errorText);
                throw new Error(response.statusText);
            }
        } catch (err) {
            // console.error('Произошла ошибка в sendDataToServerAsync:', err);
            throw err;
        }
    }

    function generateChemDocumentData() {
        let ChemDocument = getComposer().exportObjs(Kekule.ChemDocument);
        let data = "";
        for (let i = 0, l = ChemDocument.length; i < l; ++i) {
            let part = ChemDocument[i];
            data += Kekule.IO.saveFormatData(part, 'Kekule-JSON');
        }
        //console.log(data);
        return data;
    }

    function generateChemNumbersData() {
        let reactantObject = {};
        let productObject = {};

        for (let fragmentId in reactantData) {
            let fragment = reactantData[fragmentId];
            reactantObject[fragmentId] = {
                fragmentId: fragment.fragmentId,
                formula: fragment.formula,
                molarMass: fragment.molarMass,
                m: fragment.m,
                mUnit: fragment.mUnit,
                n: fragment.n,
                nUnit: fragment.nUnit,
                equivalent: fragment.equivalent,
                action: fragment.action
            };
            // console.log(reactantObject[fragmentId].fragmentId, "|", reactantObject[fragmentId].m);
        }

        for (let fragmentId in productData) {
            let fragment = productData[fragmentId];
            productObject[fragmentId] = {
                fragmentId: fragment.fragmentId,
                formula: fragment.formula,
                molarMass: fragment.molarMass,
                m: fragment.m,
                mUnit: fragment.mUnit,
                n: fragment.n,
                nUnit: fragment.nUnit,
                equivalent: fragment.equivalent,
                action: fragment.action
            };
        }

        return { reactantObject, productObject };
    }


    Kekule.X.domReady(init);

</script>

<div>
    <a asp-action="Index">Назад на главную</a>
</div>
