@model ChemLab.Data.Entity.LabPractice

@{
    ViewData["Title"] = "Details";
}

<h1 class="display-4">@ViewData["Title"]</h1>
<hr />

<link rel="stylesheet" type="text/css" href="~/lib/libs/dist/themes/default/kekule.css" />
<style>
    p {
        margin: 0.3em 0.5em;
    }

    #composer {
        height: 450px;
        width: 600px;
        float: left;
    }

    .FloatClearer {
        clear: both;
    }

    .ChemViewer {
        width: 500px;
        height: 400px;
        border: 1px solid #ccc;
    }

    .data-grid {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .formula, .action, .molarMass, .mass, .mole {
        flex: 1;
        min-width: 0;
        text-align: center;
    }

    table {
        border-collapse: collapse;
        max-width: 600px; /* Максимальная ширина таблицы */
    }

    table, th, td {
        border: 1px solid black;
    }

    th, td {
        padding: 8px;
        text-align: center;
    }

    tr:nth-child(even) {
        background-color: #f2f2f2;
    }

    #reactantTable tr:last-child {
        display: none;
    }

    #productTable tr:last-child {
        display: none;
    }
</style>

<div id="stage">
    <div id="composer" data-widget="Kekule.Editor.Composer"
         data-chem-obj="" data-resizable="true"></div>
    <div class="FloatClearer"></div>
</div>

<table id="reactantTable">
    <tr>
        <td>Формула</td>
    </tr>
    <tr>
        <td>MW</td>
    </tr>
    <tr>
        <td>m</td>
    </tr>
    <tr>
        <td>n</td>
    </tr>
    <tr>
        <td>Экв.</td>
    </tr>
    <tr>
        <td>Основной</td>
    </tr>
    <tr>
        <td><input type="hidden" name="uniqe" value="">
    </tr>
</table>

<table id="productTable">
    <tr>
        <td>Формула</td>
    </tr>
    <tr>
        <td>MW</td>
    </tr>
    <tr>
        <td>m</td>
    </tr>
    <tr>
        <td>n</td>
    </tr>
    <tr>
        <td>Экв.</td>
    </tr>
    <tr>
        <td><input type="hidden" name="uniqe" value="">
    </tr>
</table>

<script src="~/lib/libs/raphael-min.2.0.1.js"></script>
<script src="~/lib/libs/dist/kekule.js?"></script>
<script>

    function parseServerData(data) {
        let parsedData = JSON.parse(data);
        return parsedData;
    }


    function getfile() {
        let id = @ViewBag.Id;
        $.ajax({
            type: 'GET',
            url: '/chemeditor/get_file/' + id,
            contentType: 'application/json; charset=utf-8',
            success: function (data) {
                // console.log(data);
                displayData(data);
            },
            error: function (xhr, status, error) {
                console.error('Произошла ошибка при получении данных химического редактора:', error);
            }
        });
    }


    function displayData(parsedData) {
        let composer = getComposer();
        let data = Kekule.IO.loadFormatData(JSON.parse(parsedData.chemDocumentData), 'Kekule-JSON'); composer.setChemObj(data);
        
        
        let reactantData = JSON.parse(parsedData.reactantData);
        for (let fragment of reactantData) {
            reactantData[fragment.FragmentId] = {
                fragment: fragment,
                fragmentId: fragment.FragmentId,
                formula: fragment.Formula,
                molarMass: fragment.MolarMass,
                m: fragment.M,
                n: fragment.N,
                equivalent: fragment.Equivalent,
                action: fragment.Action
            };
            updateColumn(fragment.FragmentId, reactantData[fragment.FragmentId], "reactantTable", true, false);
        }

        let productData = JSON.parse(parsedData.productData);
        for (let fragment of productData) {
            productData[fragment.FragmentId] = {
                fragment: fragment,
                fragmentId: fragment.FragmentId,
                formula: fragment.Formula,
                molarMass: fragment.MolarMass,
                m: fragment.M,
                n: fragment.N,
                equivalent: fragment.Equivalent,
                action: fragment.Action
            };
            updateColumn(fragment.FragmentId, productData[fragment.FragmentId], "productTable", false, false);
        }
    }

    function updateColumn(fragmentId, updatedData, tableId, flagReactant, flagChangeMW) {
        var table = document.getElementById(tableId);
        //  убрать потом магические числа
        if (flagReactant) {
            var row = table.rows[6];
        } else {
            var row = table.rows[5];
        }
        for (var i = 1; i < row.cells.length; i++) {
            var cell = row.cells[i];
            var cellFragmentId = cell.innerHTML;
            if (cellFragmentId === fragmentId) {
                var formulaCell = table.rows[0].cells[i];
                formulaCell.innerHTML = updatedData.formula;

                var mwCell = table.rows[1].cells[i];
                mwCell.innerHTML = (updatedData.molarMass).toFixed(2);

                var mCell = table.rows[2].cells[i];
                var mInput = document.createElement("input");
                mInput.type = "text";
                mInput.className = "m-input";
                // console.log("m-input", updatedData.m);
                if (flagChangeMW) {
                    // console.log("flagChangeMW==true", fragmentId);
                    if (updatedData.m !== "") {
                        mInput.value = (updatedData.n * updatedData.molarMass / 1000).toFixed(2);
                    }
                } else {
                    // console.log("flagChangeMW==false", fragmentId);
                    mInput.value = formatNumber(updatedData.m);
                }

                mCell.innerHTML = ''; // Очищаем содержимое ячейки
                mCell.appendChild(mInput);
                mInput.addEventListener('blur', function (e) {
                    if (validateAndSetProperty(e.target, "m", updatedData)) {
                        ProcessingOtherFieldsForM(e.target.value, updatedData, tableId, flagReactant);
                    } else {
                        updatedData.m = "";
                    }
                });

                var nCell = table.rows[3].cells[i];
                var nInput = document.createElement("input");
                nInput.type = "text";
                nInput.className = "n-input";
                nInput.value = formatNumber(updatedData.n);

                nCell.innerHTML = ''; // Очищаем содержимое ячейки
                nCell.appendChild(nInput);
                nInput.addEventListener('blur', function (e) {
                    if (validateAndSetProperty(e.target, "n", updatedData)) {
                        ProcessingOtherFieldsForN(e.target.value, updatedData, tableId, flagReactant);
                    } else {
                        updatedData.n = "";
                    }
                });

                var eqvCell = table.rows[4].cells[i];
                var eqvInput = document.createElement("input");
                eqvInput.type = "text";
                eqvInput.className = "eqv-input";
                eqvInput.value = formatNumber(updatedData.equivalent);
                eqvCell.innerHTML = ''; // Очищаем содержимое ячейки
                eqvCell.appendChild(eqvInput);
                var oldValue = eqvInput.value;
                eqvInput.addEventListener('blur', function (e) {
                    if (validateAndSetProperty(e.target, "equivalent", updatedData)) {
                        ProcessingOtherFieldsForEqv(oldValue, updatedData, tableId, flagReactant);
                    } else {
                        updatedData.equivalent = 1.00;
                        updateColumn(updatedData.fragmentId, updatedData, tableId, flagReactant, false);
                    }
                });

                break; // Выйти из цикла, как только ячейка будет обновлена
            }
        }
        sendDataToServer();
    }

    function createColumn(fragmentInfo, tableId, flagReactant) {
        var table = document.getElementById(tableId);
        //  убрать потом магические числа
        var formulaRow = table.rows[0];
        var mwRow = table.rows[1];
        var mRow = table.rows[2];
        var nRow = table.rows[3];
        var eqvRow = table.rows[4];

        if (flagReactant) {
            var actionRow = table.rows[5];
            var uniqeRow = table.rows[6];
        } else {
            var uniqeRow = table.rows[5];
        }


        var formulaCell = formulaRow.insertCell(formulaRow.cells.length);
        formulaCell.innerHTML = fragmentInfo.formula;

        var mwCell = mwRow.insertCell(mwRow.cells.length);
        mwCell.innerHTML = (fragmentInfo.molarMass).toFixed(2);

        let flagFullnes = false;
        var resFullness = checkForFullness();
        if (resFullness) {
            var nValueBase = resFullness.n;
            var eqvValueBase = resFullness.equivalent;
            flagFullnes = true;
        }

        var nCell = nRow.insertCell(nRow.cells.length);
        var nInput = document.createElement("input");
        nInput.type = "text";
        nInput.className = "n-input";
        if (flagFullnes) {
            fragmentInfo.n = (nValueBase / eqvValueBase);
            nInput.value = formatNumber(fragmentInfo.n);
        } else {
            nInput.value = "";
        }
        nCell.appendChild(nInput);
        nInput.addEventListener('blur', function (e) {
            if (validateAndSetProperty(e.target, "n", fragmentInfo)) {
                ProcessingOtherFieldsForN(e.target.value, fragmentInfo, tableId, flagReactant);
            } else {
                fragmentInfo.n = "";
            }
        });

        var mCell = mRow.insertCell(mRow.cells.length);
        var mInput = document.createElement("input");
        mInput.type = "text";
        mInput.className = "m-input";
        if (flagFullnes) {
            fragmentInfo.m = (fragmentInfo.n * fragmentInfo.molarMass / 1000);
            mInput.value = formatNumber(fragmentInfo.m);
        } else {
            mInput.value = "";
        }
        mCell.appendChild(mInput);
        mInput.addEventListener('blur', function (e) {
            if (validateAndSetProperty(e.target, "m", fragmentInfo)) {
                ProcessingOtherFieldsForM(e.target.value, fragmentInfo, tableId, flagReactant);
            } else {
                fragmentInfo.m = "";
            }
        });

        var eqvCell = eqvRow.insertCell(eqvRow.cells.length);
        var eqvInput = document.createElement("input");
        eqvInput.type = "text";
        eqvInput.className = "eqv-input";
        eqvInput.value = formatNumber(fragmentInfo.equivalent);
        eqvCell.appendChild(eqvInput);
        var oldValue = eqvInput.value;
        eqvInput.addEventListener('blur', function (e) {
            if (validateAndSetProperty(e.target, "equivalent", fragmentInfo)) {
                ProcessingOtherFieldsForEqv(oldValue, fragmentInfo, tableId, flagReactant);
            } else {
                fragmentInfo.equivalent = 1.00;
            }
        });
        if (flagReactant) {

            var actionCell = actionRow.insertCell(actionRow.cells.length);
            var radioInput = document.createElement("input");
            radioInput.type = 'radio';
            radioInput.name = 'action';
            radioInput.className = 'action';

            if (fragmentInfo.action == 1) {
                radioInput.checked = true;
            }

            radioInput.addEventListener('change', () => {
                fragmentInfo.action = 1;
                resetAllActionsExcept(fragmentInfo.fragmentId);
                if (fragmentInfo.n !== "" && fragmentInfo.m !== "") {
                    updateEmptyFields(reactantData, fragmentInfo, "reactantTable", true);
                    updateEmptyFields(productData, fragmentInfo, "productTable", false);
                }
            });

            actionCell.appendChild(radioInput);

        }

        var uniqeCell = uniqeRow.insertCell(uniqeRow.cells.length);
        uniqeCell.innerHTML = fragmentInfo.fragmentId;

        sendDataToServer();
    }

    function updateEmptyFields(data, actvieFragment, tableId, flagReactant) {
        for (var key in data) {
            var element = data[key];
            if (element.action === 0) {
                if (element.n === "" && element.m === "") {
                    element.n = actvieFragment.n * element.equivalent / actvieFragment.equivalent;
                    element.m = (element.n * element.molarMass / 1000);
                    updateColumn(key, element, tableId, flagReactant, false);
                } else if (element.n === "") {
                    element.n = (element.m / element.molarMass * 1000);
                    updateColumn(key, element, tableId, flagReactant, false);
                } else if (element.m === "") {
                    element.m = (element.n * element.molarMass / 1000);
                    updateColumn(key, element, tableId, flagReactant, false);
                }
            }
        }
        sendDataToServer();
    }

    function checkForFullness() {
        var reactionElementWithAction = Object.values(reactantData).find(elem => elem.action === 1);
        if (reactionElementWithAction && reactionElementWithAction.n !== "" && reactionElementWithAction.m !== "") {
            // return reactionElementWithAction.n;
            return {
                n: reactionElementWithAction.n,
                equivalent: reactionElementWithAction.equivalent
            };
        } else {
            for (var key in productData) {
                var productElement = productData[key];
                if (productElement.n !== "" && productElement.m !== "") {
                    return {
                        n: productElement.n,
                        equivalent: productElement.equivalent
                    };
                }
            }
            return null;
        }
        sendDataToServer();
    }

    function resetAllActionsExcept(fragmentId) {
        var keys = Object.keys(reactantData);
        for (var i = 0; i < keys.length; i++) {
            var elem = reactantData[keys[i]];

            if (elem.fragmentId !== fragmentId) {
                elem.action = 0;
            }
            // console.log(elem.fragmentId, elem.action);
        }
    }



    function formatNumber(value) {
        if (/^\d+(\.\d+)?$/.test(value)) {
            return parseFloat(value).toFixed(2);
        } else {
            return value;
        }
    }

    function isNumber(value) {
        return /^\d+(\.\d+)?$/.test(value);
    }

    function validateAndSetProperty(inputElement, property, fragmentInfo) {
        var value = inputElement.value;
        inputElement.value = value;
        if (isNumber(value)) {
            fragmentInfo[property] = value;
            // console.log("valid true");
            return true;
        } else {
            // console.log("valid false");
            inputElement.style.color = 'red';
            return false;
        }
    }

    function ProcessingOtherFieldsForM(value, fragmentInfo, tableId, flagReactant) {
        var mValue = value;
        var newNvalue = (mValue / fragmentInfo.molarMass * 1000);
        fragmentInfo.n = newNvalue;
        updateColumn(fragmentInfo.fragmentId, fragmentInfo, tableId, flagReactant, false);

        if (!(flagReactant && fragmentInfo.action === 0)) {

            for (var key in reactantData) {
                if (key !== fragmentInfo.fragmentId) {
                    reactantData[key].m = (reactantData[key].molarMass / fragmentInfo.molarMass * fragmentInfo.m * reactantData[key].equivalent / fragmentInfo.equivalent);
                    reactantData[key].n = (reactantData[key].m / reactantData[key].molarMass * 1000);
                    updateColumn(key, reactantData[key], "reactantTable", true, false);
                }
            }
            for (var key in productData) {
                if (key !== fragmentInfo.fragmentId) {
                    productData[key].m = (productData[key].molarMass / fragmentInfo.molarMass * fragmentInfo.m * productData[key].equivalent / fragmentInfo.equivalent);
                    productData[key].n = (productData[key].m / productData[key].molarMass * 1000);
                    updateColumn(key, productData[key], "productTable", false, false);
                }
            }
        }
        sendDataToServer();
    }

    function ProcessingOtherFieldsForN(value, fragmentInfo, tableId, flagReactant) {

        var nValue = value;
        var newMvalue = (nValue * fragmentInfo.molarMass / 1000);
        fragmentInfo.m = newMvalue;
        updateColumn(fragmentInfo.fragmentId, fragmentInfo, tableId, flagReactant, false);

        if (!(flagReactant && fragmentInfo.action === 0)) {

            for (var key in reactantData) {
                if (key !== fragmentInfo.fragmentId) {
                    reactantData[key].n = (reactantData[key].equivalent / fragmentInfo.equivalent * fragmentInfo.n);
                    reactantData[key].m = (reactantData[key].n * reactantData[key].molarMass / 1000);
                    updateColumn(key, reactantData[key], "reactantTable", true, false);
                }
            }
            for (var key in productData) {
                if (key !== fragmentInfo.fragmentId) {
                    productData[key].n = (productData[key].equivalent / fragmentInfo.equivalent * fragmentInfo.n);
                    productData[key].m = (productData[key].n * productData[key].molarMass / 1000);
                    updateColumn(key, productData[key], "productTable", false, false);
                }
            }

        }
        sendDataToServer();
    }

    function ProcessingOtherFieldsForEqv(oldValue, fragmentInfo, tableId, flagReactant) {
        // console.log("fragmentInfo.equivalent / oldValue = ", fragmentInfo.equivalent, "*", oldValue, "=", fragmentInfo.equivalent / oldValue);

        if (flagReactant && fragmentInfo.action === 1) {
            var multiplier = fragmentInfo.equivalent / oldValue;
            updateColumn(fragmentInfo.fragmentId, fragmentInfo, tableId, flagReactant, false);
            for (var key in reactantData) {
                if (key !== fragmentInfo.fragmentId) {
                    // console.log("multiplier", multiplier);
                    reactantData[key].m /= multiplier;
                    reactantData[key].n /= multiplier;
                    updateColumn(key, reactantData[key], tableId, true, false);
                }
            }
            for (var key in productData) {
                // if (key !== fragmentInfo.fragmentId) {
                // console.log("multiplier", multiplier);
                productData[key].m /= multiplier;
                productData[key].n /= multiplier;
                updateColumn(key, productData[key], "productTable", false, false);
                // }
            }
        } else {
            var multiplier = fragmentInfo.equivalent / oldValue;
            fragmentInfo.m *= multiplier;
            fragmentInfo.n *= multiplier;
            updateColumn(fragmentInfo.fragmentId, fragmentInfo, tableId, flagReactant, false);
        }
        sendDataToServer();
    }

    function getComposer() {
        return Kekule.Widget.getWidgetById('composer');
    }

    var reactantData = {};
    var productData = {};

    function init() {
        localStorage.removeItem('xCoordinateArrow');
        var composer = getComposer();
        getfile();

        composer.setChemToolButtons(['manipulate', 'erase', 'bond', 'atom', 'formula', 'ring', 'charge', 'glyph', 'textBlock']);

        composer.getEditor().on('operChange', handleOperationChangeOrUndo);
        composer.getEditor().on('operUndo', handleOperationChangeOrUndo);
        composer.getEditor().on('operRedo', handleOperationChangeOrUndo);

        var newDocumentButton = document.querySelector('.K-Chem-NewDoc');

        newDocumentButton.addEventListener('click', removeAllColumnsExceptFirst);

    }

    function handleOperationChangeOrUndo(e) {

        var composer = getComposer();
        var chemObj = composer.getChemObj();

        //var arrows = composer.exportObjs(Kekule.Glyph.StraightLine);

        var arrows = composer.exportObjs(Kekule.Glyph.ReactionArrow);
        var xOffset = 1.2;
        if ((arrows.length > 0 && !localStorage.getItem('xCoordinateArrow')) ||
            (arrows.length > 0 && arrows[0].__$__k__p__coord2D.x + xOffset !== parseFloat(localStorage.getItem('xCoordinateArrow')))) {
            var xCoordinateArrow = arrows[0].__$__k__p__coord2D.x + xOffset;
            localStorage.setItem('xCoordinateArrow', xCoordinateArrow);
            composer.setChemToolButtons(['manipulate', 'erase', 'bond', 'atom', 'formula', 'ring', 'charge', 'textBlock']);
        } else if (!(arrows.length > 0)) {
            if (document.querySelector('.K-Chem-ArrowLineIaController') == null) {
                composer.setChemToolButtons(['manipulate', 'erase', 'bond', 'atom', 'formula', 'ring', 'charge', 'glyph', 'textBlock']);
                localStorage.removeItem('xCoordinateArrow');
            }
        }


        var fragments = Kekule.ChemStructureUtils.getAllStructFragments(chemObj, true);

        if (fragments.length == 0) {
            removeAllColumnsExceptFirst();
        } else {
            var observedFragmentIdsReactant = {};
            var observedFragmentIdsProduct = {};
            for (var i = 0; i < fragments.length; i++) {
                var fragment = fragments[i];
                var fragmentId = fragment.__$__k__p__id;

                if (fragment && fragment.__$__k__p__coord2D) {
                    var node = fragment.getNodeAt(0);
                    var xCoordinateAtom = fragment.__$__k__p__coord2D.x;
                    // console.log("X atom=", xCoordinateAtom);
                } else if (fragment && !fragment.__$__k__p__coord2D) {
                    var node = fragment.getNodeAt(0);
                    var xCoordinateAtom = node.__$__k__p__coord2D.x;
                    // console.log("X atom=", xCoordinateAtom);
                }

                var xCoordinateArrow = localStorage.getItem('xCoordinateArrow') || 0;
                // console.log(fragmentId);
                var flagReactant = true;
                // console.log("true", fragmentId);
                if (xCoordinateArrow === 0 || (xCoordinateArrow !== 0 && xCoordinateAtom < xCoordinateArrow)) {
                    observedFragmentIdsReactant[fragmentId] = true;
                    processFragment(reactantData, fragments, fragment, fragmentId, "reactantTable", flagReactant);
                } else {
                    observedFragmentIdsProduct[fragmentId] = true;
                    processFragment(productData, fragments, fragment, fragmentId, "productTable", !flagReactant);
                }
            }


            deleteFragment(reactantData, "reactantTable", observedFragmentIdsReactant, flagReactant);
            deleteFragment(productData, "productTable", observedFragmentIdsProduct, !flagReactant);
        }


    }

    function deleteFragment(fragmentData, tableId, observedFragmentIds, flagReactant) {

        var flagSetAction = false;
        var columnsToDelete = [];

        for (var existingFragmentId in fragmentData) {
            if (!observedFragmentIds[existingFragmentId]) {
                columnsToDelete.push(existingFragmentId);
            }
        }
        if (columnsToDelete.length > 0) {
            var tmp = 5;  //  магические числа
            if (flagReactant) {
                tmp = 6;
            }
            // Удаляем столбцы из таблицы в обратном порядке
            var table = document.getElementById(tableId);
            for (var i = columnsToDelete.length - 1; i >= 0; i--) {
                var fragmentId = columnsToDelete[i];
                for (var j = 0; j < table.rows[tmp].cells.length; j++) {
                    if (table.rows[tmp].cells[j].innerHTML === fragmentId) {
                        for (var k = 0; k < table.rows.length; k++) {
                            table.rows[k].deleteCell(j);
                        }
                    }
                }
                if (flagReactant && Object.keys(fragmentData).length > 1 && fragmentData[fragmentId].action === 1) {
                    flagSetAction = true;
                }
                // console.log("delete", fragmentId);
                delete fragmentData[fragmentId];
            }
        }
        if (flagReactant && flagSetAction) {
            var fragmentIds = Object.keys(fragmentData);
            var firstFragmentId = fragmentIds[0];
            fragmentData[firstFragmentId].action = 1;
            var radioButtons = document.getElementsByClassName('action');
            radioButtons[0].checked = true;
        }
        sendDataToServer();
    }

    function processFragment(fragmentData, fragments, fragment, fragmentId, tableId, flagReactant) {
        var totalMass = 0;
        for (var i = 0, l = fragment.getNodeCount(); i < l; ++i) {
            var node = fragment.getNodeAt(i);
            if (node.getAtomicMass) {
                totalMass += node.getAtomicMass();
            }
            if (node.getImplicitHydrogenCount) {
                var hcount = node.getImplicitHydrogenCount() || 0;
                totalMass += hcount * 1.01;
            }
        }
        var molarMass = totalMass

        if (!fragmentData[fragmentId]) {

            var formula = fragment.calcFormula();
            var formulaText = parseFormula(formula.getText());

            fragmentData[fragmentId] = {
                fragment: fragment,
                fragmentId: fragmentId,
                formula: formulaText,
                molarMass: molarMass,
                m: "",
                n: "",
                equivalent: 1.00,
                action: 0
            };
            // console.log("add new", fragmentId, flagReactant, Object.keys(fragmentData).length);
            if (Object.keys(fragmentData).length == 1 && flagReactant) {
                fragmentData[fragmentId].action = 1;
            }
            createColumn(fragmentData[fragmentId], tableId, flagReactant);
        } else if (fragmentData[fragmentId].formula !== parseFormula((fragment.calcFormula()).getText())) {
            // console.log("update", fragmentId, flagReactant);
            var formula = fragment.calcFormula();
            var formulaText = parseFormula(formula.getText());

            fragmentData[fragmentId].formula = formulaText;
            fragmentData[fragmentId].molarMass = molarMass;
            updateColumn(fragmentId, fragmentData[fragmentId], tableId, flagReactant, true);
        }
    }

    function parseFormula(inputString) {
        inputString = inputString.trim();
        const match = inputString.match(/([+-])$/);
        if (match) {
            inputString = inputString.slice(0, -2);
        }
        var result = "";
        var sign = '';
        var num = 1;
        for (var i = 0; i < inputString.length; i++) {
            if (inputString[i] !== ' ') {
                result += inputString[i];
            } else {
                if (i + 1 < inputString.length) {
                    if (!isNaN(inputString[i + 1])) {
                        num = 0;
                        while (i + 1 < inputString.length && !isNaN(inputString[i + 1])) {
                            num = num * 10 + parseInt(inputString[i + 1]);
                            i++;
                        }
                    }
                    if (inputString[i + 1] === '+') {
                        sign = '+';
                        i++;
                    } else if (inputString[i + 1] === '-') {
                        sign = '-';
                        i++;
                    }
                }

            }
        }
        if (sign) {
            const chars = sign.repeat(num);
            result += chars;
        }
        return result;
    }

    function removeAllColumnsExceptFirst() {
        var composer = getComposer();
        localStorage.clear();
        composer.setChemToolButtons(['manipulate', 'erase', 'bond', 'atom', 'formula', 'ring', 'charge', 'glyph', 'textBlock']);
        var table = document.getElementById("reactantTable");
        for (var i = table.rows[0].cells.length - 1; i > 0; i--) {
            for (var j = 0; j < table.rows.length; j++) {
                table.rows[j].deleteCell(i);
            }
        }
        reactantData = {};
        var table = document.getElementById("productTable");
        for (var i = table.rows[0].cells.length - 1; i > 0; i--) {
            for (var j = 0; j < table.rows.length; j++) {
                table.rows[j].deleteCell(i);
            }
        }
        productData = {};
    }

    function sendDataToServer() {
        let chemDocumentData = generateChemDocumentData();
        let chemNumbersData = generateChemNumbersData();

        dataReactant = chemNumbersData.reactantArray;
        dataProduct = chemNumbersData.productArray;

        let dataContainer = {
            ChemDocumentData: chemDocumentData,
            ReactantData: dataReactant,
            ProductData: dataProduct
        };
        let id = @ViewBag.Id;

        $.ajax({
            type: 'POST',
            url: '/chemeditor/save_data/' + id,
            data: JSON.stringify(dataContainer),
            contentType: 'application/json; charset=utf-8',
            success: function (data) {
                console.log('Данные успешно сохранены на сервере.');
            },
            error: function (xhr, status, error) {
                console.error('Произошла ошибка при отправке данных на сервер:', error);
            }
        });
    }

    function generateChemDocumentData() {
        let ChemDocument = getComposer().exportObjs(Kekule.ChemDocument);
        let data = "";
        for (let i = 0, l = ChemDocument.length; i < l; ++i) {
            let part = ChemDocument[i];
            data += Kekule.IO.saveFormatData(part, 'Kekule-JSON');
        }
        //console.log(data);
        return data;
    }

    function generateChemNumbersData() {
        let reactantArray = [];
        let productArray = [];

        for (let fragmentId in reactantData) {
            let fragment = reactantData[fragmentId];
            reactantArray.push({
                fragmentId: fragmentId,
                formula: fragment.formula,
                molarMass: fragment.molarMass,
                m: fragment.m,
                n: fragment.n,
                equivalent: fragment.equivalent,
                action: fragment.action
            });
        }

        for (let fragmentId in productData) {
            let fragment = productData[fragmentId];
            productArray.push({
                fragmentId: fragmentId,
                formula: fragment.formula,
                molarMass: fragment.molarMass,
                m: fragment.m,
                n: fragment.n,
                equivalent: fragment.equivalent,
                action: fragment.action
            });
        }

        return { reactantArray, productArray };
    }
    /*
    var ctrlPressed = false;

    document.addEventListener('keydown', function (event) {
        //console.log("listen", event);
        if (event.key === 'Control') {
            ctrlPressed = true;
        } else if (ctrlPressed && event.key === 'z') {
            activateUndo();
        } else if (ctrlPressed && event.key === '1') {
            event.preventDefault();
            handleBondType('Single');
        } else if (ctrlPressed && event.key === '2') {
            event.preventDefault();
            handleBondType('Double');
        } else if (ctrlPressed && event.key === '3') {
            event.preventDefault();
            handleBondType('Triple');
        }
    });

    // Обработчик отпускания клавиши Ctrl
    document.addEventListener('keyup', function (event) {
        //console.log("keyup");
        if (event.key === 'Control') {
            ctrlPressed = false;
        }
    });

    // Общая функция для обработки типа связи
    function handleBondType(bondType) {
        var bondTool = document.querySelector('.K-Chem-MolBondIaController');

        if (bondTool) {
            var mousedownEvent = new MouseEvent('mousedown', {
                view: window,
                bubbles: true,
                cancelable: true
            });

            var mouseupEvent = new MouseEvent('mouseup', {
                view: window,
                bubbles: true,
                cancelable: true
            });

            bondTool.dispatchEvent(mousedownEvent);
            bondTool.dispatchEvent(mouseupEvent);

            var bondButton = document.querySelector('.K-Chem-MolBondIaController-' + bondType);

            if (bondButton) {
                bondButton.dispatchEvent(mousedownEvent);
                bondButton.dispatchEvent(mouseupEvent);

                bondButton.dispatchEvent(mousedownEvent);
            }
        }
    }

    // Функция для выполнения отмены действия
    function activateUndo() {
        var backButton = document.querySelector('.K-Chem-Undo'); // Найдите кнопку "назад" с помощью селектора
        if (backButton) {
            console.log("click");
            backButton.click(); // Имитируем щелчок по кнопке "назад"
            getComposer().undo();
        }
    }

    */

    Kekule.X.domReady(init);

</script>

<div>
    <a asp-action="Index">Назад на главную</a>
</div>
